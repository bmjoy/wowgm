#pragma once
#include "Instance.hpp"
#include "Queue.hpp"

#include <vector>
#include <memory>                // for enable_shared_from_this
#include <cstdint>               // for uint32_t
#include <vulkan/vulkan_core.h>  // for VkDevice, VkDevice_T

namespace wowgm::graphics
{
    class SwapChain;
    class CommandBuffer;
    class Semaphore;
    class Fence;
    class RenderPass;
    struct QueueFamilyIndices;

    /*
     * The logical device is one the most important objects created in our application. It represents real hardware,
     * along with all the extensions and features enabled for it and all the queues requested from it:
     *
     * The logical device allows us to perform almost all the work typically done in rendering applications, such as
     * creating images and buffers, setting the pipeline state, or loading shaders. The most important ability it
     * gives us is recording commands (such as issuing draw calls or dispatching computational work) and submitting
     * them to queues, where they are executed and processed by the given hardware. After such execution, we acquire
     * the results of the submitted operations. These can be a set of values calculated by compute shaders, or other
     * data (not necessarily an image) generated by draw calls. All this is performed on a logical device.
     */
    class LogicalDevice : public std::enable_shared_from_this<LogicalDevice>
    {
        friend LogicalDevice* Instance::CreateLogicalDevice();
        LogicalDevice(VkDevice device, QueueFamilyIndices& indices);

        LogicalDevice(LogicalDevice&&) = delete;
        LogicalDevice(const LogicalDevice&) = delete;

    public:
        ~LogicalDevice();

        LogicalDevice() = delete;

        Queue* GetGraphicsQueue();

        Queue* GetPresentQueue();

        std::uint32_t AcquireNextImage(SwapChain* swapChain);

        void AddWaitFence(Fence* fence);
        void AddWaitFence(VkFence fence);

        void Submit(std::uint32_t imageIndex, SwapChain* swapChain, Fence* submitFence);
        void Present(std::uint32_t imageToPresent, SwapChain* swapChain, Semaphore* waitSemaphore);

        void AddCommandBuffer(std::uint32_t frameIndex, CommandBuffer* buffer);

        operator VkDevice() const { return _device; }

        void WaitIdle();

        Semaphore* CreateSemaphore();
        Fence* CreateFence();
        Queue* CreateQueue(VkQueueFlagBits queueType, VkQueue queueObject, std::int32_t indice);
        RenderPass* CreateRenderPass();

        Semaphore* GetImageAvailableSemaphore();
        Semaphore* GetSignalSemaphore();
        Fence* GetFlightFence();

    private:
        VkDevice _device;

        // Mirrors into the `_ownedQueues` vector.
        Queue* _graphicsQueue;
        Queue* _presentQueue;

        std::vector<Queue*> _ownedQueues;

        std::vector<VkFence> _waitFences;

        static const constexpr std::uint32_t MAX_FRAMES_IN_FLIGHT = 3;

        std::vector<Semaphore*> _ownedSemaphores;
        std::vector<Fence*> _ownedFences;
        std::unordered_map<std::uint32_t, std::vector<CommandBuffer*>> _ownedCommandBuffers;
        std::vector<RenderPass*> _ownedRenderPasses;

        // These mirror into the vectors above.
        Semaphore* _imageAvailable[MAX_FRAMES_IN_FLIGHT];
        Semaphore* _renderFinished[MAX_FRAMES_IN_FLIGHT];
        Fence* _inflightFence[MAX_FRAMES_IN_FLIGHT];

        std::uint32_t _currentFrame = 0;
    };
}

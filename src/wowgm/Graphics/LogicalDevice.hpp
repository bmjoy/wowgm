#pragma once
#include "Instance.hpp"

#include <vector>
#include <memory>
#include <vulkan/vulkan.h>

namespace wowgm::graphics
{
    class PhysicalDevice;
    class Queue;
    class SwapChain;
    class Semaphore;
    class CommandBuffer;
    class Fence;
    class CommandPool;
    struct QueueFamilyIndices;

    /*
     * The logical device is one the most important objects created in our application. It represents real hardware,
     * along with all the extensions and features enabled for it and all the queues requested from it:
     *
     * The logical device allows us to perform almost all the work typically done in rendering applications, such as
     * creating images and buffers, setting the pipeline state, or loading shaders. The most important ability it
     * gives us is recording commands (such as issuing draw calls or dispatching computational work) and submitting
     * them to queues, where they are executed and processed by the given hardware. After such execution, we acquire
     * the results of the submitted operations. These can be a set of values calculated by compute shaders, or other
     * data (not necessarily an image) generated by draw calls. All this is performed on a logical device.
     */
    class LogicalDevice : public std::enable_shared_from_this<LogicalDevice>
    {
        friend LogicalDevice* Instance::CreateLogicalDevice();
        LogicalDevice(VkDevice device, QueueFamilyIndices& indices);

        LogicalDevice(LogicalDevice&&) = delete;
        LogicalDevice(const LogicalDevice&) = delete;

    public:
        ~LogicalDevice();

        LogicalDevice() = delete;

        Queue* GetGraphicsQueue();

        Queue* GetPresentQueue();

        void Draw(SwapChain* swapChain);

        void AddCommandBuffer(CommandBuffer* buffer);

        operator VkDevice() const { return _device; }

        void WaitIdle();

    private:
        VkDevice _device;

        // This *needs* to be in the same order as indices defined in QueueFamilyIndices.
        // (We are more or less memcpy-ing)
        std::unique_ptr<Queue> _graphicsQueue;
        std::unique_ptr<Queue> _presentQueue;

        static const constexpr std::uint32_t MAX_FRAMES_IN_FLIGHT = 2;

        Semaphore* _imageAvailable[MAX_FRAMES_IN_FLIGHT];
        Semaphore* _renderFinished[MAX_FRAMES_IN_FLIGHT];
        Fence* _inflightFence[MAX_FRAMES_IN_FLIGHT];
        std::vector<CommandBuffer*> _commandBuffers;

        std::uint32_t _currentFrame = 0;
    };
}

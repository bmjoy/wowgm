#pragma once

#include <type_traits>
#include <cstdint>
#include <vector>

// AUTOGENERATED FILE - DO NOT EDIT
// See contrib/dbmeta.py
namespace wowgm::game::datastores
{
    template <typename T>
    struct DBMeta {
        static void AdjustStringOffsets(std::uint8_t* record, std::uint32_t stringTableOffset) {
            if (!T::has_string)
                return;

            for (std::uint32_t i = 0; i < T::field_count; ++i) {
                if (T::field_types[i] != 's')
                    continue;

                *reinterpret_cast<std::uintptr_t*>(record + T::field_offsets[i]) += stringTableOffset;
            }
        }
    };

    struct Startup_StringsMeta : public DBMeta<Startup_StringsMeta> {
        constexpr Startup_StringsMeta() { }

        constexpr static const std::uint32_t field_count = 3;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 12; // 0xC
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8
        };
        constexpr static const char field_types[] = "nss";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "Startup_Strings.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ItemSparseMeta : public DBMeta<ItemSparseMeta> {
        constexpr ItemSparseMeta() { }

        constexpr static const std::uint32_t field_count = 68;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 532; // 0x214
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  16,  20,  24,  28,  32,  36,  40,
            44,  48,  52,  56,  60,  64,  68,  72,  76,  80,
            84,  88,  92,  96, 136, 176, 216, 256, 260, 264,
            268, 272, 292, 312, 332, 352, 372, 392, 396, 400,
            404, 408, 412, 416, 420, 424, 428, 432, 436, 440,
            444, 448, 452, 456, 460, 464, 468, 472, 484, 496,
            500, 504, 508, 512, 516, 520, 524, 528
        };
        constexpr static const char field_types[] = "niiffiiiiiiiiiiiiiiiiiiiiiiiiifiiiiiiisssssiiiiiiiiiiiiiiiiiifiiifii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   2,   1,   1,   1,   1,   1,   1,   1,
            1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
            1,   1,   1,  10,  10,  10,  10,   1,   1,   1,
            1,   5,   5,   5,   5,   5,   5,   1,   1,   1,
            1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
            1,   1,   1,   1,   1,   1,   1,   3,   3,   1,
            1,   1,   1,   1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = true;
        constexpr static const bool has_string = true;

        static const char* name() { return "Item-sparse.db2"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ItemMeta : public DBMeta<ItemMeta> {
        constexpr ItemMeta() { }

        constexpr static const std::uint32_t field_count = 8;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 32; // 0x20
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24,  28
        };
        constexpr static const char field_types[] = "niiiiiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = true;
        constexpr static const bool has_string = false;

        static const char* name() { return "Item.db2"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SpellVisualKitMeta : public DBMeta<SpellVisualKitMeta> {
        constexpr SpellVisualKitMeta() { }

        constexpr static const std::uint32_t field_count = 22;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 156; // 0x9C
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24,  28,  32,  36,
            40,  44,  48,  60,  64,  68,  72,  88, 104, 120,
            136, 152
        };
        constexpr static const char field_types[] = "niiiiiiiiiiiiiiiiffffi";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
            1,   1,   3,   1,   1,   1,   4,   4,   4,   4,
            4,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "SpellVisualKit.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SpellVisualEffectNameMeta : public DBMeta<SpellVisualEffectNameMeta> {
        constexpr SpellVisualEffectNameMeta() { }

        constexpr static const std::uint32_t field_count = 9;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 36; // 0x24
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24,  28,  32
        };
        constexpr static const char field_types[] = "nssffffif";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1,   0,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "SpellVisualEffectName.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SpellEffectMeta : public DBMeta<SpellEffectMeta> {
        constexpr SpellEffectMeta() { }

        constexpr static const std::uint32_t field_count = 22;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 108; // 0x6C
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24,  28,  32,  36,
            40,  44,  48,  56,  60,  68,  72,  84,  88,  96,
            100, 104
        };
        constexpr static const char field_types[] = "nifiiiffiiiiififiiiiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
            1,   1,   2,   1,   2,   1,   3,   1,   2,   1,
            1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "SpellEffect.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ParticleColorMeta : public DBMeta<ParticleColorMeta> {
        constexpr ParticleColorMeta() { }

        constexpr static const std::uint32_t field_count = 4;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 40; // 0x28
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,  16,  28
        };
        constexpr static const char field_types[] = "niii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   3,   3,   3
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "ParticleColor.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ObjectEffectPackageElemMeta : public DBMeta<ObjectEffectPackageElemMeta> {
        constexpr ObjectEffectPackageElemMeta() { }

        constexpr static const std::uint32_t field_count = 4;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 16; // 0x10
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12
        };
        constexpr static const char field_types[] = "niii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "ObjectEffectPackageElem.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ObjectEffectPackageMeta : public DBMeta<ObjectEffectPackageMeta> {
        constexpr ObjectEffectPackageMeta() { }

        constexpr static const std::uint32_t field_count = 2;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 8; // 0x8
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4
        };
        constexpr static const char field_types[] = "ns";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "ObjectEffectPackage.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ObjectEffectModifierMeta : public DBMeta<ObjectEffectModifierMeta> {
        constexpr ObjectEffectModifierMeta() { }

        constexpr static const std::uint32_t field_count = 5;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 32; // 0x20
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16
        };
        constexpr static const char field_types[] = "niiif";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   4
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "ObjectEffectModifier.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ObjectEffectGroupMeta : public DBMeta<ObjectEffectGroupMeta> {
        constexpr ObjectEffectGroupMeta() { }

        constexpr static const std::uint32_t field_count = 2;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 8; // 0x8
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4
        };
        constexpr static const char field_types[] = "ns";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "ObjectEffectGroup.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ObjectEffectMeta : public DBMeta<ObjectEffectMeta> {
        constexpr ObjectEffectMeta() { }

        constexpr static const std::uint32_t field_count = 10;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 48; // 0x30
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24,  28,  32,  44

        };
        constexpr static const char field_types[] = "nsiiiiiifi";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1,   1,   3,   1

        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "ObjectEffect.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct NameGenMeta : public DBMeta<NameGenMeta> {
        constexpr NameGenMeta() { }

        constexpr static const std::uint32_t field_count = 4;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 16; // 0x10
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12
        };
        constexpr static const char field_types[] = "nsii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "NameGen.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct LoadingScreensMeta : public DBMeta<LoadingScreensMeta> {
        constexpr LoadingScreensMeta() { }

        constexpr static const std::uint32_t field_count = 4;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 16; // 0x10
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12
        };
        constexpr static const char field_types[] = "nssi";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "LoadingScreens.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ItemVisualEffectsMeta : public DBMeta<ItemVisualEffectsMeta> {
        constexpr ItemVisualEffectsMeta() { }

        constexpr static const std::uint32_t field_count = 2;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 8; // 0x8
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4
        };
        constexpr static const char field_types[] = "ns";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "ItemVisualEffects.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ItemVisualsMeta : public DBMeta<ItemVisualsMeta> {
        constexpr ItemVisualsMeta() { }

        constexpr static const std::uint32_t field_count = 2;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 24; // 0x18
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4
        };
        constexpr static const char field_types[] = "ni";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   5
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "ItemVisuals.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ItemDisplayInfoMeta : public DBMeta<ItemDisplayInfoMeta> {
        constexpr ItemDisplayInfoMeta() { }

        constexpr static const std::uint32_t field_count = 12;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 100; // 0x64
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,  12,  20,  28,  40,  44,  48,  52,  60,
            92,  96
        };
        constexpr static const char field_types[] = "nsssiiiiisii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   2,   2,   2,   3,   1,   1,   1,   2,   8,
            1,   1
        };
        constexpr static const bool sparse_storage = true;
        constexpr static const bool has_string = true;

        static const char* name() { return "ItemDisplayInfo.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct HelmetGeosetVisDataMeta : public DBMeta<HelmetGeosetVisDataMeta> {
        constexpr HelmetGeosetVisDataMeta() { }

        constexpr static const std::uint32_t field_count = 2;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 32; // 0x20
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4
        };
        constexpr static const char field_types[] = "ni";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   7
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "HelmetGeosetVisData.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct GuildColorEmblemMeta : public DBMeta<GuildColorEmblemMeta> {
        constexpr GuildColorEmblemMeta() { }

        constexpr static const std::uint32_t field_count = 4;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 8; // 0x8
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   5,   6
        };
        constexpr static const char field_types[] = "niii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   0,   0,   0
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "GuildColorEmblem.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct GuildColorBorderMeta : public DBMeta<GuildColorBorderMeta> {
        constexpr GuildColorBorderMeta() { }

        constexpr static const std::uint32_t field_count = 4;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 8; // 0x8
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   5,   6
        };
        constexpr static const char field_types[] = "niii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   0,   0,   0
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "GuildColorBorder.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct GuildColorBackgroundMeta : public DBMeta<GuildColorBackgroundMeta> {
        constexpr GuildColorBackgroundMeta() { }

        constexpr static const std::uint32_t field_count = 4;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 8; // 0x8
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   5,   6
        };
        constexpr static const char field_types[] = "niii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   0,   0,   0
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "GuildColorBackground.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct GlueScreenEmoteMeta : public DBMeta<GlueScreenEmoteMeta> {
        constexpr GlueScreenEmoteMeta() { }

        constexpr static const std::uint32_t field_count = 8;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 32; // 0x20
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24,  28
        };
        constexpr static const char field_types[] = "niiiiiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "GlueScreenEmote.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct GameTipsMeta : public DBMeta<GameTipsMeta> {
        constexpr GameTipsMeta() { }

        constexpr static const std::uint32_t field_count = 4;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 16; // 0x10
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12
        };
        constexpr static const char field_types[] = "nsii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "GameTips.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct CreatureModelDataMeta : public DBMeta<CreatureModelDataMeta> {
        constexpr CreatureModelDataMeta() { }

        constexpr static const std::uint32_t field_count = 27;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 124; // 0x7C
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24,  28,  32,  36,
            40,  44,  48,  52,  56,  60,  64,  68,  80,  92,
            96, 100, 104, 108, 112, 116, 120
        };
        constexpr static const char field_types[] = "nisifiifffiiiifffffffffffff";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
            1,   1,   1,   1,   1,   1,   1,   3,   3,   1,
            1,   1,   1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "CreatureModelData.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct CreatureFamilyMeta : public DBMeta<CreatureFamilyMeta> {
        constexpr CreatureFamilyMeta() { }

        constexpr static const std::uint32_t field_count = 11;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 48; // 0x30
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  28,  32,  36,  40,
            44
        };
        constexpr static const char field_types[] = "nfifiiiiiss";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   2,   1,   1,   1,   1,
            1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "CreatureFamily.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct CreatureDisplayInfoExtraMeta : public DBMeta<CreatureDisplayInfoExtraMeta> {
        constexpr CreatureDisplayInfoExtraMeta() { }

        constexpr static const std::uint32_t field_count = 11;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 84; // 0x54
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24,  28,  32,  76,
            80
        };
        constexpr static const char field_types[] = "niiiiiiiiis";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1,   1,  11,   1,
            1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "CreatureDisplayInfoExtra.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct CreatureDisplayInfoMeta : public DBMeta<CreatureDisplayInfoMeta> {
        constexpr CreatureDisplayInfoMeta() { }

        constexpr static const std::uint32_t field_count = 15;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 68; // 0x44
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24,  36,  40,  44,
            48,  52,  56,  60,  64
        };
        constexpr static const char field_types[] = "niiifissiiiiiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   3,   1,   1,   1,
            1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "CreatureDisplayInfo.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct CharStartOutfitMeta : public DBMeta<CharStartOutfitMeta> {
        constexpr CharStartOutfitMeta() { }

        constexpr static const std::uint32_t field_count = 10;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 304; // 0x130
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   5,   6,   7,   8, 104, 200, 296, 300

        };
        constexpr static const char field_types[] = "niiiiiiiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   0,   0,   0,   0,  24,  24,  24,   1,   1

        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "CharStartOutfit.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct AnimReplacementSetMeta : public DBMeta<AnimReplacementSetMeta> {
        constexpr AnimReplacementSetMeta() { }

        constexpr static const std::uint32_t field_count = 2;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 8; // 0x8
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4
        };
        constexpr static const char field_types[] = "ni";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "AnimReplacementSet.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct AnimReplacementMeta : public DBMeta<AnimReplacementMeta> {
        constexpr AnimReplacementMeta() { }

        constexpr static const std::uint32_t field_count = 4;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 16; // 0x10
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12
        };
        constexpr static const char field_types[] = "niii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "AnimReplacement.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct AnimKitSegmentMeta : public DBMeta<AnimKitSegmentMeta> {
        constexpr AnimKitSegmentMeta() { }

        constexpr static const std::uint32_t field_count = 16;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 64; // 0x40
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24,  28,  32,  36,
            40,  44,  48,  52,  56,  60
        };
        constexpr static const char field_types[] = "niiiiiiiiiifiiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
            1,   1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "AnimKitSegment.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct AnimKitPriorityMeta : public DBMeta<AnimKitPriorityMeta> {
        constexpr AnimKitPriorityMeta() { }

        constexpr static const std::uint32_t field_count = 2;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 8; // 0x8
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4
        };
        constexpr static const char field_types[] = "ni";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "AnimKitPriority.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SoundProviderPreferencesMeta : public DBMeta<SoundProviderPreferencesMeta> {
        constexpr SoundProviderPreferencesMeta() { }

        constexpr static const std::uint32_t field_count = 24;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 96; // 0x60
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24,  28,  32,  36,
            40,  44,  48,  52,  56,  60,  64,  68,  72,  76,
            80,  84,  88,  92
        };
        constexpr static const char field_types[] = "nsiifffiifififffifffffff";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
            1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
            1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "SoundProviderPreferences.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SpamMessagesMeta : public DBMeta<SpamMessagesMeta> {
        constexpr SpamMessagesMeta() { }

        constexpr static const std::uint32_t field_count = 2;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 8; // 0x8
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4
        };
        constexpr static const char field_types[] = "ns";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "SpamMessages.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SoundFilterElemMeta : public DBMeta<SoundFilterElemMeta> {
        constexpr SoundFilterElemMeta() { }

        constexpr static const std::uint32_t field_count = 5;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 52; // 0x34
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16
        };
        constexpr static const char field_types[] = "niiif";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   9
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "SoundFilterElem.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SoundFilterMeta : public DBMeta<SoundFilterMeta> {
        constexpr SoundFilterMeta() { }

        constexpr static const std::uint32_t field_count = 2;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 8; // 0x8
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4
        };
        constexpr static const char field_types[] = "ns";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "SoundFilter.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ResistancesMeta : public DBMeta<ResistancesMeta> {
        constexpr ResistancesMeta() { }

        constexpr static const std::uint32_t field_count = 4;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 16; // 0x10
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12
        };
        constexpr static const char field_types[] = "niis";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "Resistances.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct NamesReservedMeta : public DBMeta<NamesReservedMeta> {
        constexpr NamesReservedMeta() { }

        constexpr static const std::uint32_t field_count = 3;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 12; // 0xC
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8
        };
        constexpr static const char field_types[] = "nsi";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "NamesReserved.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct NamesProfanityMeta : public DBMeta<NamesProfanityMeta> {
        constexpr NamesProfanityMeta() { }

        constexpr static const std::uint32_t field_count = 3;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 12; // 0xC
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8
        };
        constexpr static const char field_types[] = "nsi";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "NamesProfanity.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct MovieVariationMeta : public DBMeta<MovieVariationMeta> {
        constexpr MovieVariationMeta() { }

        constexpr static const std::uint32_t field_count = 3;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 12; // 0xC
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8
        };
        constexpr static const char field_types[] = "nii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "MovieVariation.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct MovieFileDataMeta : public DBMeta<MovieFileDataMeta> {
        constexpr MovieFileDataMeta() { }

        constexpr static const std::uint32_t field_count = 2;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 8; // 0x8
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4
        };
        constexpr static const char field_types[] = "ni";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "MovieFileData.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct MovieMeta : public DBMeta<MovieMeta> {
        constexpr MovieMeta() { }

        constexpr static const std::uint32_t field_count = 4;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 16; // 0x10
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12
        };
        constexpr static const char field_types[] = "nsii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "Movie.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ItemSubClassMeta : public DBMeta<ItemSubClassMeta> {
        constexpr ItemSubClassMeta() { }

        constexpr static const std::uint32_t field_count = 12;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 52; // 0x34
        constexpr static const std::uint32_t field_offsets[] = {
            4,   8,  12,  16,  20,  24,  28,  32,  36,  40,
            44,  48
        };
        constexpr static const char field_types[] = "niiiiiiiiiss";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
            1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "ItemSubClass.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ItemClassMeta : public DBMeta<ItemClassMeta> {
        constexpr ItemClassMeta() { }

        constexpr static const std::uint32_t field_count = 5;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 24; // 0x18
        constexpr static const std::uint32_t field_offsets[] = {
            4,   8,  12,  16,  20
        };
        constexpr static const char field_types[] = "niifs";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "ItemClass.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct FileDataMeta : public DBMeta<FileDataMeta> {
        constexpr FileDataMeta() { }

        constexpr static const std::uint32_t field_count = 3;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 12; // 0xC
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8
        };
        constexpr static const char field_types[] = "nss";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "FileData.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct FactionTemplateMeta : public DBMeta<FactionTemplateMeta> {
        constexpr FactionTemplateMeta() { }

        constexpr static const std::uint32_t field_count = 8;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 56; // 0x38
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24,  40
        };
        constexpr static const char field_types[] = "niiiiiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   4,   4
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "FactionTemplate.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct FactionGroupMeta : public DBMeta<FactionGroupMeta> {
        constexpr FactionGroupMeta() { }

        constexpr static const std::uint32_t field_count = 4;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 16; // 0x10
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12
        };
        constexpr static const char field_types[] = "niss";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "FactionGroup.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ChrRacesMeta : public DBMeta<ChrRacesMeta> {
        constexpr ChrRacesMeta() { }

        constexpr static const std::uint32_t field_count = 23;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 96; // 0x60
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24,  28,  32,  36,
            40,  44,  48,  52,  56,  60,  64,  68,  76,  80,
            84,  88,  92
        };
        constexpr static const char field_types[] = "niiiiisiiiisiisssssiiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
            1,   1,   1,   1,   1,   1,   1,   2,   1,   1,
            1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "ChrRaces.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ChrClassesMeta : public DBMeta<ChrClassesMeta> {
        constexpr ChrClassesMeta() { }

        constexpr static const std::uint32_t field_count = 14;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 56; // 0x38
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24,  28,  32,  36,
            40,  44,  48,  52
        };
        constexpr static const char field_types[] = "nisssssiiiiiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
            1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "ChrClasses.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ChatProfanityMeta : public DBMeta<ChatProfanityMeta> {
        constexpr ChatProfanityMeta() { }

        constexpr static const std::uint32_t field_count = 3;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 12; // 0xC
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8
        };
        constexpr static const char field_types[] = "nsi";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "ChatProfanity.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct CharacterFacialHairStylesMeta : public DBMeta<CharacterFacialHairStylesMeta> {
        constexpr CharacterFacialHairStylesMeta() { }

        constexpr static const std::uint32_t field_count = 4;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 36; // 0x24
        constexpr static const std::uint32_t field_offsets[] = {
            4,   8,  12,  16
        };
        constexpr static const char field_types[] = "niii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   5
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "CharacterFacialHairStyles.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct CharSectionsMeta : public DBMeta<CharSectionsMeta> {
        constexpr CharSectionsMeta() { }

        constexpr static const std::uint32_t field_count = 8;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 40; // 0x28
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  28,  32,  36
        };
        constexpr static const char field_types[] = "niiisiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   3,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "CharSections.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct CharHairGeosetsMeta : public DBMeta<CharHairGeosetsMeta> {
        constexpr CharHairGeosetsMeta() { }

        constexpr static const std::uint32_t field_count = 6;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 24; // 0x18
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20
        };
        constexpr static const char field_types[] = "niiiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "CharHairGeosets.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct CharBaseInfoMeta : public DBMeta<CharBaseInfoMeta> {
        constexpr CharBaseInfoMeta() { }

        constexpr static const std::uint32_t field_count = 2;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 8; // 0x8
        constexpr static const std::uint32_t field_offsets[] = {
            4,   5
        };
        constexpr static const char field_types[] = "ni";
        constexpr static const std::uint32_t array_sizes[] = {
            0,   0
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "CharBaseInfo.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct Cfg_ConfigsMeta : public DBMeta<Cfg_ConfigsMeta> {
        constexpr Cfg_ConfigsMeta() { }

        constexpr static const std::uint32_t field_count = 4;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 20; // 0x14
        constexpr static const std::uint32_t field_offsets[] = {
            4,   8,  12,  16
        };
        constexpr static const char field_types[] = "niii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "Cfg_Configs.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct Cfg_CategoriesMeta : public DBMeta<Cfg_CategoriesMeta> {
        constexpr Cfg_CategoriesMeta() { }

        constexpr static const std::uint32_t field_count = 6;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 24; // 0x18
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20
        };
        constexpr static const char field_types[] = "niiiis";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "Cfg_Categories.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct BannedAddOnsMeta : public DBMeta<BannedAddOnsMeta> {
        constexpr BannedAddOnsMeta() { }

        constexpr static const std::uint32_t field_count = 5;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 44; // 0x2C
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,  20,  36,  40
        };
        constexpr static const char field_types[] = "niiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   4,   4,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "BannedAddOns.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct AnimKitConfigBoneSetMeta : public DBMeta<AnimKitConfigBoneSetMeta> {
        constexpr AnimKitConfigBoneSetMeta() { }

        constexpr static const std::uint32_t field_count = 4;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 16; // 0x10
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12
        };
        constexpr static const char field_types[] = "niii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "AnimKitConfigBoneSet.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct AnimKitConfigMeta : public DBMeta<AnimKitConfigMeta> {
        constexpr AnimKitConfigMeta() { }

        constexpr static const std::uint32_t field_count = 2;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 8; // 0x8
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4
        };
        constexpr static const char field_types[] = "ni";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "AnimKitConfig.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct AnimKitMeta : public DBMeta<AnimKitMeta> {
        constexpr AnimKitMeta() { }

        constexpr static const std::uint32_t field_count = 3;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 12; // 0xC
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8
        };
        constexpr static const char field_types[] = "nii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "AnimKit.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct AnimKitBoneSetMeta : public DBMeta<AnimKitBoneSetMeta> {
        constexpr AnimKitBoneSetMeta() { }

        constexpr static const std::uint32_t field_count = 6;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 24; // 0x18
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20
        };
        constexpr static const char field_types[] = "nsiiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "AnimKitBoneSet.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct AnimKitBoneSetAliasMeta : public DBMeta<AnimKitBoneSetAliasMeta> {
        constexpr AnimKitBoneSetAliasMeta() { }

        constexpr static const std::uint32_t field_count = 3;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 12; // 0xC
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8
        };
        constexpr static const char field_types[] = "nii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "AnimKitBoneSetAlias.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct PhaseShiftZoneSoundsMeta : public DBMeta<PhaseShiftZoneSoundsMeta> {
        constexpr PhaseShiftZoneSoundsMeta() { }

        constexpr static const std::uint32_t field_count = 14;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 56; // 0x38
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24,  28,  32,  36,
            40,  44,  48,  52
        };
        constexpr static const char field_types[] = "niiiiiiiiiiiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
            1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "PhaseShiftZoneSounds.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct WorldChunkSoundsMeta : public DBMeta<WorldChunkSoundsMeta> {
        constexpr WorldChunkSoundsMeta() { }

        constexpr static const std::uint32_t field_count = 9;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 40; // 0x28
        constexpr static const std::uint32_t field_offsets[] = {
            4,   8,  12,  16,  20,  24,  28,  32,  36
        };
        constexpr static const char field_types[] = "niiiiiiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "WorldChunkSounds.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct WorldStateZoneSoundsMeta : public DBMeta<WorldStateZoneSoundsMeta> {
        constexpr WorldStateZoneSoundsMeta() { }

        constexpr static const std::uint32_t field_count = 8;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 36; // 0x24
        constexpr static const std::uint32_t field_offsets[] = {
            4,   8,  12,  16,  20,  24,  28,  32
        };
        constexpr static const char field_types[] = "niiiiiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "WorldStateZoneSounds.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ZoneMusicMeta : public DBMeta<ZoneMusicMeta> {
        constexpr ZoneMusicMeta() { }

        constexpr static const std::uint32_t field_count = 5;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 32; // 0x20
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  16,  24
        };
        constexpr static const char field_types[] = "nsiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   2,   2,   2
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "ZoneMusic.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ZoneIntroMusicTableMeta : public DBMeta<ZoneIntroMusicTableMeta> {
        constexpr ZoneIntroMusicTableMeta() { }

        constexpr static const std::uint32_t field_count = 5;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 20; // 0x14
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16
        };
        constexpr static const char field_types[] = "nsiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "ZoneIntroMusicTable.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct WorldStateUIMeta : public DBMeta<WorldStateUIMeta> {
        constexpr WorldStateUIMeta() { }

        constexpr static const std::uint32_t field_count = 15;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 68; // 0x44
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24,  28,  32,  36,
            40,  44,  48,  52,  56
        };
        constexpr static const char field_types[] = "niiiiisssiisssi";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
            1,   1,   1,   1,   3
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "WorldStateUI.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct WorldSafeLocsMeta : public DBMeta<WorldSafeLocsMeta> {
        constexpr WorldSafeLocsMeta() { }

        constexpr static const std::uint32_t field_count = 4;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 24; // 0x18
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  20
        };
        constexpr static const char field_types[] = "nifs";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   3,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "WorldSafeLocs.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct WorldMapTransformsMeta : public DBMeta<WorldMapTransformsMeta> {
        constexpr WorldMapTransformsMeta() { }

        constexpr static const std::uint32_t field_count = 9;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 48; // 0x30
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  16,  24,  28,  36,  40,  44
        };
        constexpr static const char field_types[] = "niffifiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   2,   2,   1,   2,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "WorldMapTransforms.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct WorldMapOverlayMeta : public DBMeta<WorldMapOverlayMeta> {
        constexpr WorldMapOverlayMeta() { }

        constexpr static const std::uint32_t field_count = 12;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 60; // 0x3C
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  24,  28,  32,  36,  40,  44,  48,
            52,  56
        };
        constexpr static const char field_types[] = "niisiiiiiiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   4,   1,   1,   1,   1,   1,   1,   1,
            1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "WorldMapOverlay.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct WorldMapContinentMeta : public DBMeta<WorldMapContinentMeta> {
        constexpr WorldMapContinentMeta() { }

        constexpr static const std::uint32_t field_count = 11;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 56; // 0x38
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24,  32,  36,  44,
            52
        };
        constexpr static const char field_types[] = "niiiiiffffi";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   2,   1,   2,   2,
            1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "WorldMapContinent.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct WorldMapAreaMeta : public DBMeta<WorldMapAreaMeta> {
        constexpr WorldMapAreaMeta() { }

        constexpr static const std::uint32_t field_count = 14;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 56; // 0x38
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24,  28,  32,  36,
            40,  44,  48,  52
        };
        constexpr static const char field_types[] = "niisffffiiiiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
            1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "WorldMapArea.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct WeaponSwingSounds2Meta : public DBMeta<WeaponSwingSounds2Meta> {
        constexpr WeaponSwingSounds2Meta() { }

        constexpr static const std::uint32_t field_count = 4;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 16; // 0x10
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12
        };
        constexpr static const char field_types[] = "niii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "WeaponSwingSounds2.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct WeaponImpactSoundsMeta : public DBMeta<WeaponImpactSoundsMeta> {
        constexpr WeaponImpactSoundsMeta() { }

        constexpr static const std::uint32_t field_count = 5;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 92; // 0x5C
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  52
        };
        constexpr static const char field_types[] = "niiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,  10,  10
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "WeaponImpactSounds.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct World_PVP_AreaMeta : public DBMeta<World_PVP_AreaMeta> {
        constexpr World_PVP_AreaMeta() { }

        constexpr static const std::uint32_t field_count = 7;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 28; // 0x1C
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24
        };
        constexpr static const char field_types[] = "niiiiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "World_PVP_Area.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct VocalUISoundsMeta : public DBMeta<VocalUISoundsMeta> {
        constexpr VocalUISoundsMeta() { }

        constexpr static const std::uint32_t field_count = 5;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 28; // 0x1C
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  20
        };
        constexpr static const char field_types[] = "niiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   2,   2
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "VocalUISounds.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct VehicleUIIndSeatMeta : public DBMeta<VehicleUIIndSeatMeta> {
        constexpr VehicleUIIndSeatMeta() { }

        constexpr static const std::uint32_t field_count = 5;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 20; // 0x14
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16
        };
        constexpr static const char field_types[] = "niiff";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "VehicleUIIndSeat.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct VehicleUIIndicatorMeta : public DBMeta<VehicleUIIndicatorMeta> {
        constexpr VehicleUIIndicatorMeta() { }

        constexpr static const std::uint32_t field_count = 2;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 8; // 0x8
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4
        };
        constexpr static const char field_types[] = "ns";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "VehicleUIIndicator.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct VehicleSeatMeta : public DBMeta<VehicleSeatMeta> {
        constexpr VehicleSeatMeta() { }

        constexpr static const std::uint32_t field_count = 62;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 264; // 0x108
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  24,  28,  32,  36,  40,  44,
            48,  52,  56,  60,  64,  68,  72,  76,  80,  84,
            88,  92,  96, 100, 104, 108, 112, 116, 120, 124,
            128, 132, 136, 140, 144, 148, 152, 156, 160, 164,
            168, 172, 176, 180, 184, 188, 192, 196, 200, 212,
            216, 220, 224, 228, 232, 236, 240, 244, 248, 252,
            256, 260
        };
        constexpr static const char field_types[] = "niiffffffffiiiiiifffffffiiifffiiiiiiiffiiiiiffffffffffiiiiiiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   3,   1,   1,   1,   1,   1,   1,
            1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
            1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
            1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
            1,   1,   1,   1,   1,   1,   1,   1,   3,   1,
            1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
            1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "VehicleSeat.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct VehicleMeta : public DBMeta<VehicleMeta> {
        constexpr VehicleMeta() { }

        constexpr static const std::uint32_t field_count = 29;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 160; // 0xA0
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24,  56,  60,  64,
            68,  72,  76,  80,  84,  88,  92,  96, 100, 104,
            108, 116, 120, 124, 132, 136, 140, 144, 148
        };
        constexpr static const char field_types[] = "niffffiffffffffffffffsssfifii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   8,   1,   1,   1,
            1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
            2,   1,   1,   2,   1,   1,   1,   1,   3
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "Vehicle.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct UnitPowerBarMeta : public DBMeta<UnitPowerBarMeta> {
        constexpr UnitPowerBarMeta() { }

        constexpr static const std::uint32_t field_count = 17;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 108; // 0x6C
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24,  28,  32,  56,
            80,  84,  88,  92,  96, 100, 104
        };
        constexpr static const char field_types[] = "niiiiffiiiissssff";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1,   1,   6,   6,
            1,   1,   1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "UnitPowerBar.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct UnitBloodMeta : public DBMeta<UnitBloodMeta> {
        constexpr UnitBloodMeta() { }

        constexpr static const std::uint32_t field_count = 4;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 40; // 0x28
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,  12,  20
        };
        constexpr static const char field_types[] = "niis";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   2,   2,   5
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "UnitBlood.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct UnitBloodLevelsMeta : public DBMeta<UnitBloodLevelsMeta> {
        constexpr UnitBloodLevelsMeta() { }

        constexpr static const std::uint32_t field_count = 2;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 16; // 0x10
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4
        };
        constexpr static const char field_types[] = "ni";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   3
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "UnitBloodLevels.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct TransportRotationMeta : public DBMeta<TransportRotationMeta> {
        constexpr TransportRotationMeta() { }

        constexpr static const std::uint32_t field_count = 4;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 28; // 0x1C
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12
        };
        constexpr static const char field_types[] = "niif";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   4
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "TransportRotation.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct TransportPhysicsMeta : public DBMeta<TransportPhysicsMeta> {
        constexpr TransportPhysicsMeta() { }

        constexpr static const std::uint32_t field_count = 11;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 44; // 0x2C
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24,  28,  32,  36,
            40
        };
        constexpr static const char field_types[] = "nffffffffff";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
            1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "TransportPhysics.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct TransportAnimationMeta : public DBMeta<TransportAnimationMeta> {
        constexpr TransportAnimationMeta() { }

        constexpr static const std::uint32_t field_count = 5;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 28; // 0x1C
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  24
        };
        constexpr static const char field_types[] = "niifi";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   3,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "TransportAnimation.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct TotemCategoryMeta : public DBMeta<TotemCategoryMeta> {
        constexpr TotemCategoryMeta() { }

        constexpr static const std::uint32_t field_count = 4;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 16; // 0x10
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12
        };
        constexpr static const char field_types[] = "nsii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "TotemCategory.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct TerrainTypeSoundsMeta : public DBMeta<TerrainTypeSoundsMeta> {
        constexpr TerrainTypeSoundsMeta() { }

        constexpr static const std::uint32_t field_count = 1;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 4; // 0x4
        constexpr static const std::uint32_t field_offsets[] = {
            0
        };
        constexpr static const char field_types[] = "n";
        constexpr static const std::uint32_t array_sizes[] = {
            1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "TerrainTypeSounds.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct TaxiPathMeta : public DBMeta<TaxiPathMeta> {
        constexpr TaxiPathMeta() { }

        constexpr static const std::uint32_t field_count = 4;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 16; // 0x10
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12
        };
        constexpr static const char field_types[] = "niii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "TaxiPath.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct TaxiPathNodeMeta : public DBMeta<TaxiPathNodeMeta> {
        constexpr TaxiPathNodeMeta() { }

        constexpr static const std::uint32_t field_count = 9;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 44; // 0x2C
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  28,  32,  36,  40
        };
        constexpr static const char field_types[] = "niiifiiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   3,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "TaxiPathNode.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct TaxiNodesMeta : public DBMeta<TaxiNodesMeta> {
        constexpr TaxiNodesMeta() { }

        constexpr static const std::uint32_t field_count = 7;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 44; // 0x2C
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  20,  24,  32,  36
        };
        constexpr static const char field_types[] = "nifsiif";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   3,   1,   2,   1,   2
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "TaxiNodes.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct TalentTreePrimarySpellsMeta : public DBMeta<TalentTreePrimarySpellsMeta> {
        constexpr TalentTreePrimarySpellsMeta() { }

        constexpr static const std::uint32_t field_count = 4;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 16; // 0x10
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12
        };
        constexpr static const char field_types[] = "niii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "TalentTreePrimarySpells.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct TalentTabMeta : public DBMeta<TalentTabMeta> {
        constexpr TalentTabMeta() { }

        constexpr static const std::uint32_t field_count = 10;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 44; // 0x2C
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24,  28,  32,  36

        };
        constexpr static const char field_types[] = "nsiiiissii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1,   1,   1,   2

        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "TalentTab.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct TalentMeta : public DBMeta<TalentMeta> {
        constexpr TalentMeta() { }

        constexpr static const std::uint32_t field_count = 10;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 76; // 0x4C
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  36,  48,  60,  64,  68

        };
        constexpr static const char field_types[] = "niiiiiiiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   5,   3,   3,   1,   1,   2

        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "Talent.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SummonPropertiesMeta : public DBMeta<SummonPropertiesMeta> {
        constexpr SummonPropertiesMeta() { }

        constexpr static const std::uint32_t field_count = 6;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 24; // 0x18
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20
        };
        constexpr static const char field_types[] = "niiiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "SummonProperties.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct StringLookupsMeta : public DBMeta<StringLookupsMeta> {
        constexpr StringLookupsMeta() { }

        constexpr static const std::uint32_t field_count = 2;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 8; // 0x8
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4
        };
        constexpr static const char field_types[] = "ns";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "StringLookups.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct StationeryMeta : public DBMeta<StationeryMeta> {
        constexpr StationeryMeta() { }

        constexpr static const std::uint32_t field_count = 4;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 16; // 0x10
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12
        };
        constexpr static const char field_types[] = "nisi";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "Stationery.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SpellVisualKitModelAttachMeta : public DBMeta<SpellVisualKitModelAttachMeta> {
        constexpr SpellVisualKitModelAttachMeta() { }

        constexpr static const std::uint32_t field_count = 12;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 56; // 0x38
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  28,  32,  36,  40,  44,
            48,  52
        };
        constexpr static const char field_types[] = "niiiffffiiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   3,   1,   1,   1,   1,   1,
            1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "SpellVisualKitModelAttach.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SpellVisualKitAreaModelMeta : public DBMeta<SpellVisualKitAreaModelMeta> {
        constexpr SpellVisualKitAreaModelMeta() { }

        constexpr static const std::uint32_t field_count = 7;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 28; // 0x1C
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24
        };
        constexpr static const char field_types[] = "nsiifff";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "SpellVisualKitAreaModel.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SpellVisualMeta : public DBMeta<SpellVisualMeta> {
        constexpr SpellVisualMeta() { }

        constexpr static const std::uint32_t field_count = 29;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 132; // 0x84
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24,  28,  32,  36,
            40,  44,  48,  52,  56,  60,  64,  68,  72,  76,
            80,  84,  88,  92,  96, 100, 104, 116, 128
        };
        constexpr static const char field_types[] = "niiiiiiiiiiiiiiiiiiiiiiiiiffi";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
            1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
            1,   1,   1,   1,   1,   1,   3,   3,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "SpellVisual.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SpellTotemsMeta : public DBMeta<SpellTotemsMeta> {
        constexpr SpellTotemsMeta() { }

        constexpr static const std::uint32_t field_count = 3;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 20; // 0x14
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,  12
        };
        constexpr static const char field_types[] = "nii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   2,   2
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "SpellTotems.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SpellTargetRestrictionsMeta : public DBMeta<SpellTargetRestrictionsMeta> {
        constexpr SpellTargetRestrictionsMeta() { }

        constexpr static const std::uint32_t field_count = 6;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 24; // 0x18
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20
        };
        constexpr static const char field_types[] = "nfiiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "SpellTargetRestrictions.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SpellSpecialUnitEffectMeta : public DBMeta<SpellSpecialUnitEffectMeta> {
        constexpr SpellSpecialUnitEffectMeta() { }

        constexpr static const std::uint32_t field_count = 2;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 8; // 0x8
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4
        };
        constexpr static const char field_types[] = "ni";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "SpellSpecialUnitEffect.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SpellShapeshiftFormMeta : public DBMeta<SpellShapeshiftFormMeta> {
        constexpr SpellShapeshiftFormMeta() { }

        constexpr static const std::uint32_t field_count = 11;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 84; // 0x54
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24,  28,  44,  76,
            80
        };
        constexpr static const char field_types[] = "nisiiiiiiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1,   4,   8,   1,
            1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "SpellShapeshiftForm.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SpellShapeshiftMeta : public DBMeta<SpellShapeshiftMeta> {
        constexpr SpellShapeshiftMeta() { }

        constexpr static const std::uint32_t field_count = 4;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 24; // 0x18
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,  12,  20
        };
        constexpr static const char field_types[] = "niii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   2,   2,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "SpellShapeshift.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SpellScalingMeta : public DBMeta<SpellScalingMeta> {
        constexpr SpellScalingMeta() { }

        constexpr static const std::uint32_t field_count = 10;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 64; // 0x40
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  32,  44,  56,  60

        };
        constexpr static const char field_types[] = "niiiiffffi";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   3,   3,   3,   1,   1

        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "SpellScaling.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SpellRuneCostMeta : public DBMeta<SpellRuneCostMeta> {
        constexpr SpellRuneCostMeta() { }

        constexpr static const std::uint32_t field_count = 5;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 20; // 0x14
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16
        };
        constexpr static const char field_types[] = "niiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "SpellRuneCost.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SpellReagentsMeta : public DBMeta<SpellReagentsMeta> {
        constexpr SpellReagentsMeta() { }

        constexpr static const std::uint32_t field_count = 3;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 68; // 0x44
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,  36
        };
        constexpr static const char field_types[] = "nii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   8,   8
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "SpellReagents.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SpellPowerMeta : public DBMeta<SpellPowerMeta> {
        constexpr SpellPowerMeta() { }

        constexpr static const std::uint32_t field_count = 8;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 32; // 0x20
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24,  28
        };
        constexpr static const char field_types[] = "niiiiiif";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "SpellPower.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SpellRangeMeta : public DBMeta<SpellRangeMeta> {
        constexpr SpellRangeMeta() { }

        constexpr static const std::uint32_t field_count = 6;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 32; // 0x20
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,  12,  20,  24,  28
        };
        constexpr static const char field_types[] = "nffiss";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   2,   2,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "SpellRange.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SpellRadiusMeta : public DBMeta<SpellRadiusMeta> {
        constexpr SpellRadiusMeta() { }

        constexpr static const std::uint32_t field_count = 4;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 16; // 0x10
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12
        };
        constexpr static const char field_types[] = "nfff";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "SpellRadius.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SpellMissileMotionMeta : public DBMeta<SpellMissileMotionMeta> {
        constexpr SpellMissileMotionMeta() { }

        constexpr static const std::uint32_t field_count = 5;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 20; // 0x14
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16
        };
        constexpr static const char field_types[] = "nssii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "SpellMissileMotion.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SpellMissileMeta : public DBMeta<SpellMissileMeta> {
        constexpr SpellMissileMeta() { }

        constexpr static const std::uint32_t field_count = 15;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 60; // 0x3C
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24,  28,  32,  36,
            40,  44,  48,  52,  56
        };
        constexpr static const char field_types[] = "nifffffffffffff";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
            1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "SpellMissile.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SpellMechanicMeta : public DBMeta<SpellMechanicMeta> {
        constexpr SpellMechanicMeta() { }

        constexpr static const std::uint32_t field_count = 2;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 8; // 0x8
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4
        };
        constexpr static const char field_types[] = "ns";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "SpellMechanic.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SpellLevelsMeta : public DBMeta<SpellLevelsMeta> {
        constexpr SpellLevelsMeta() { }

        constexpr static const std::uint32_t field_count = 4;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 16; // 0x10
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12
        };
        constexpr static const char field_types[] = "niii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "SpellLevels.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SpellItemEnchantmentConditionMeta : public DBMeta<SpellItemEnchantmentConditionMeta> {
        constexpr SpellItemEnchantmentConditionMeta() { }

        constexpr static const std::uint32_t field_count = 7;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 72; // 0x48
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,  12,  32,  37,  44,  64
        };
        constexpr static const char field_types[] = "niiiiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   5,   1,   1,   5,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "SpellItemEnchantmentCondition.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SpellItemEnchantmentMeta : public DBMeta<SpellItemEnchantmentMeta> {
        constexpr SpellItemEnchantmentMeta() { }

        constexpr static const std::uint32_t field_count = 15;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 92; // 0x5C
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  20,  32,  44,  56,  60,  64,  68,
            72,  76,  80,  84,  88
        };
        constexpr static const char field_types[] = "niiiiisiiiiiiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   3,   3,   3,   3,   1,   1,   1,   1,
            1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "SpellItemEnchantment.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SpellInterruptsMeta : public DBMeta<SpellInterruptsMeta> {
        constexpr SpellInterruptsMeta() { }

        constexpr static const std::uint32_t field_count = 4;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 24; // 0x18
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,  12,  20
        };
        constexpr static const char field_types[] = "niii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   2,   2,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "SpellInterrupts.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SpellIconMeta : public DBMeta<SpellIconMeta> {
        constexpr SpellIconMeta() { }

        constexpr static const std::uint32_t field_count = 2;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 8; // 0x8
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4
        };
        constexpr static const char field_types[] = "ns";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "SpellIcon.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SpellFocusObjectMeta : public DBMeta<SpellFocusObjectMeta> {
        constexpr SpellFocusObjectMeta() { }

        constexpr static const std::uint32_t field_count = 2;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 8; // 0x8
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4
        };
        constexpr static const char field_types[] = "ns";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "SpellFocusObject.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SpellFlyoutItemMeta : public DBMeta<SpellFlyoutItemMeta> {
        constexpr SpellFlyoutItemMeta() { }

        constexpr static const std::uint32_t field_count = 4;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 16; // 0x10
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12
        };
        constexpr static const char field_types[] = "niii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "SpellFlyoutItem.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SpellFlyoutMeta : public DBMeta<SpellFlyoutMeta> {
        constexpr SpellFlyoutMeta() { }

        constexpr static const std::uint32_t field_count = 7;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 28; // 0x1C
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24
        };
        constexpr static const char field_types[] = "niiiiss";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "SpellFlyout.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SpellEquippedItemsMeta : public DBMeta<SpellEquippedItemsMeta> {
        constexpr SpellEquippedItemsMeta() { }

        constexpr static const std::uint32_t field_count = 4;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 16; // 0x10
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12
        };
        constexpr static const char field_types[] = "niii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "SpellEquippedItems.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SpellEffectCameraShakesMeta : public DBMeta<SpellEffectCameraShakesMeta> {
        constexpr SpellEffectCameraShakesMeta() { }

        constexpr static const std::uint32_t field_count = 2;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 16; // 0x10
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4
        };
        constexpr static const char field_types[] = "ni";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   3
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "SpellEffectCameraShakes.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SpellDurationMeta : public DBMeta<SpellDurationMeta> {
        constexpr SpellDurationMeta() { }

        constexpr static const std::uint32_t field_count = 4;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 16; // 0x10
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12
        };
        constexpr static const char field_types[] = "niii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "SpellDuration.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SpellDispelTypeMeta : public DBMeta<SpellDispelTypeMeta> {
        constexpr SpellDispelTypeMeta() { }

        constexpr static const std::uint32_t field_count = 5;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 20; // 0x14
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16
        };
        constexpr static const char field_types[] = "nsiis";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "SpellDispelType.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SpellDifficultyMeta : public DBMeta<SpellDifficultyMeta> {
        constexpr SpellDifficultyMeta() { }

        constexpr static const std::uint32_t field_count = 2;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 20; // 0x14
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4
        };
        constexpr static const char field_types[] = "ni";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   4
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "SpellDifficulty.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SpellDescriptionVariablesMeta : public DBMeta<SpellDescriptionVariablesMeta> {
        constexpr SpellDescriptionVariablesMeta() { }

        constexpr static const std::uint32_t field_count = 2;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 8; // 0x8
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4
        };
        constexpr static const char field_types[] = "ns";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "SpellDescriptionVariables.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SpellMeta : public DBMeta<SpellMeta> {
        constexpr SpellMeta() { }

        constexpr static const std::uint32_t field_count = 47;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 192; // 0xC0
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24,  28,  32,  36,
            40,  44,  48,  52,  56,  60,  64,  68,  76,  80,
            84,  88,  92,  96, 100, 104, 108, 112, 116, 120,
            124, 128, 132, 136, 140, 144, 148, 152, 156, 160,
            164, 168, 172, 176, 180, 184, 188
        };
        constexpr static const char field_types[] = "niiiiiiiiiiiiiiifiiissssiiiiifiiiiiiiiiiiiiiiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
            1,   1,   1,   1,   1,   1,   1,   2,   1,   1,
            1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
            1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
            1,   1,   1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "Spell.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SpellCooldownsMeta : public DBMeta<SpellCooldownsMeta> {
        constexpr SpellCooldownsMeta() { }

        constexpr static const std::uint32_t field_count = 4;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 16; // 0x10
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12
        };
        constexpr static const char field_types[] = "niii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "SpellCooldowns.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SpellClassOptionsMeta : public DBMeta<SpellClassOptionsMeta> {
        constexpr SpellClassOptionsMeta() { }

        constexpr static const std::uint32_t field_count = 5;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 28; // 0x1C
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  20,  24
        };
        constexpr static const char field_types[] = "niiis";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   3,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "SpellClassOptions.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SpellChainEffectsMeta : public DBMeta<SpellChainEffectsMeta> {
        constexpr SpellChainEffectsMeta() { }

        constexpr static const std::uint32_t field_count = 48;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 180; // 0xB4
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24,  28,  32,  36,
            40,  44,  48,  52,  56,  60,  64,  68,  72,  76,
            80,  84,  88,  92,  96, 100, 104, 108, 112, 116,
            120, 124, 128, 132, 136, 140, 144, 148, 152, 156,
            157, 158, 159, 160, 164, 168, 172, 176
        };
        constexpr static const char field_types[] = "nffffiisiifiiffffffffffffffffffffffffffiiiiisiff";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
            1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
            1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
            1,   1,   1,   1,   1,   1,   1,   1,   1,   0,
            0,   0,   0,   0,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "SpellChainEffects.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SpellCategoryMeta : public DBMeta<SpellCategoryMeta> {
        constexpr SpellCategoryMeta() { }

        constexpr static const std::uint32_t field_count = 4;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 16; // 0x10
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12
        };
        constexpr static const char field_types[] = "niis";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   0,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "SpellCategory.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SpellCategoriesMeta : public DBMeta<SpellCategoriesMeta> {
        constexpr SpellCategoriesMeta() { }

        constexpr static const std::uint32_t field_count = 7;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 28; // 0x1C
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24
        };
        constexpr static const char field_types[] = "niiiiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "SpellCategories.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SpellCastTimesMeta : public DBMeta<SpellCastTimesMeta> {
        constexpr SpellCastTimesMeta() { }

        constexpr static const std::uint32_t field_count = 4;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 16; // 0x10
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12
        };
        constexpr static const char field_types[] = "niii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "SpellCastTimes.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SpellCastingRequirementsMeta : public DBMeta<SpellCastingRequirementsMeta> {
        constexpr SpellCastingRequirementsMeta() { }

        constexpr static const std::uint32_t field_count = 7;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 28; // 0x1C
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24
        };
        constexpr static const char field_types[] = "niiiiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "SpellCastingRequirements.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SpellAuraVisXTalentTabMeta : public DBMeta<SpellAuraVisXTalentTabMeta> {
        constexpr SpellAuraVisXTalentTabMeta() { }

        constexpr static const std::uint32_t field_count = 3;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 12; // 0xC
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8
        };
        constexpr static const char field_types[] = "nii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "SpellAuraVisXTalentTab.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SpellAuraVisibilityMeta : public DBMeta<SpellAuraVisibilityMeta> {
        constexpr SpellAuraVisibilityMeta() { }

        constexpr static const std::uint32_t field_count = 4;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 16; // 0x10
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12
        };
        constexpr static const char field_types[] = "niii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "SpellAuraVisibility.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SpellAuraRestrictionsMeta : public DBMeta<SpellAuraRestrictionsMeta> {
        constexpr SpellAuraRestrictionsMeta() { }

        constexpr static const std::uint32_t field_count = 9;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 36; // 0x24
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24,  28,  32
        };
        constexpr static const char field_types[] = "niiiiiiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "SpellAuraRestrictions.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SpellAuraOptionsMeta : public DBMeta<SpellAuraOptionsMeta> {
        constexpr SpellAuraOptionsMeta() { }

        constexpr static const std::uint32_t field_count = 5;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 20; // 0x14
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16
        };
        constexpr static const char field_types[] = "niiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "SpellAuraOptions.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SpellActivationOverlayMeta : public DBMeta<SpellActivationOverlayMeta> {
        constexpr SpellActivationOverlayMeta() { }

        constexpr static const std::uint32_t field_count = 9;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 44; // 0x2C
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24,  36,  40
        };
        constexpr static const char field_types[] = "niiiifiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   3,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "SpellActivationOverlay.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SoundAmbienceFlavorMeta : public DBMeta<SoundAmbienceFlavorMeta> {
        constexpr SoundAmbienceFlavorMeta() { }

        constexpr static const std::uint32_t field_count = 4;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 16; // 0x10
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12
        };
        constexpr static const char field_types[] = "niii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "SoundAmbienceFlavor.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SoundAmbienceMeta : public DBMeta<SoundAmbienceMeta> {
        constexpr SoundAmbienceMeta() { }

        constexpr static const std::uint32_t field_count = 2;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 12; // 0xC
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4
        };
        constexpr static const char field_types[] = "ni";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   2
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "SoundAmbience.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SkillTiersMeta : public DBMeta<SkillTiersMeta> {
        constexpr SkillTiersMeta() { }

        constexpr static const std::uint32_t field_count = 3;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 132; // 0x84
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,  68
        };
        constexpr static const char field_types[] = "nii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,  16,  16
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "SkillTiers.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SkillRaceClassInfoMeta : public DBMeta<SkillRaceClassInfoMeta> {
        constexpr SkillRaceClassInfoMeta() { }

        constexpr static const std::uint32_t field_count = 9;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 36; // 0x24
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24,  28,  32
        };
        constexpr static const char field_types[] = "niiiiiiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "SkillRaceClassInfo.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SkillLineMeta : public DBMeta<SkillLineMeta> {
        constexpr SkillLineMeta() { }

        constexpr static const std::uint32_t field_count = 7;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 28; // 0x1C
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24
        };
        constexpr static const char field_types[] = "nissisi";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "SkillLine.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SkillLineCategoryMeta : public DBMeta<SkillLineCategoryMeta> {
        constexpr SkillLineCategoryMeta() { }

        constexpr static const std::uint32_t field_count = 3;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 12; // 0xC
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8
        };
        constexpr static const char field_types[] = "nsi";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "SkillLineCategory.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SkillLineAbilitySortedSpellMeta : public DBMeta<SkillLineAbilitySortedSpellMeta> {
        constexpr SkillLineAbilitySortedSpellMeta() { }

        constexpr static const std::uint32_t field_count = 2;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 8; // 0x8
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4
        };
        constexpr static const char field_types[] = "ni";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "SkillLineAbilitySortedSpell.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SkillLineAbilityMeta : public DBMeta<SkillLineAbilityMeta> {
        constexpr SkillLineAbilityMeta() { }

        constexpr static const std::uint32_t field_count = 14;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 56; // 0x38
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24,  28,  32,  36,
            40,  44,  48,  52
        };
        constexpr static const char field_types[] = "niiiiiiiiiiiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
            1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "SkillLineAbility.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ServerMessagesMeta : public DBMeta<ServerMessagesMeta> {
        constexpr ServerMessagesMeta() { }

        constexpr static const std::uint32_t field_count = 2;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 8; // 0x8
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4
        };
        constexpr static const char field_types[] = "ns";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "ServerMessages.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ScreenLocationMeta : public DBMeta<ScreenLocationMeta> {
        constexpr ScreenLocationMeta() { }

        constexpr static const std::uint32_t field_count = 2;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 8; // 0x8
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4
        };
        constexpr static const char field_types[] = "ns";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "ScreenLocation.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ScreenEffectMeta : public DBMeta<ScreenEffectMeta> {
        constexpr ScreenEffectMeta() { }

        constexpr static const std::uint32_t field_count = 8;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 44; // 0x2C
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  28,  32,  36,  40
        };
        constexpr static const char field_types[] = "nsiiiiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   4,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "ScreenEffect.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ScalingStatValuesMeta : public DBMeta<ScalingStatValuesMeta> {
        constexpr ScalingStatValuesMeta() { }

        constexpr static const std::uint32_t field_count = 23;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 188; // 0xBC
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24,  28,  32,  36,
            40,  44,  48,  52,  56,  72,  88, 104, 120, 136,
            152, 168, 184
        };
        constexpr static const char field_types[] = "niiiiiiiiiiiiiiiiiiiiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
            1,   1,   1,   1,   4,   4,   4,   4,   4,   4,
            4,   4,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "ScalingStatValues.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ScalingStatDistributionMeta : public DBMeta<ScalingStatDistributionMeta> {
        constexpr ScalingStatDistributionMeta() { }

        constexpr static const std::uint32_t field_count = 5;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 92; // 0x5C
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,  44,  84,  88
        };
        constexpr static const char field_types[] = "niiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,  10,  10,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "ScalingStatDistribution.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct RandPropPointsMeta : public DBMeta<RandPropPointsMeta> {
        constexpr RandPropPointsMeta() { }

        constexpr static const std::uint32_t field_count = 4;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 64; // 0x40
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,  24,  44
        };
        constexpr static const char field_types[] = "niii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   5,   5,   5
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "RandPropPoints.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ResearchSiteMeta : public DBMeta<ResearchSiteMeta> {
        constexpr ResearchSiteMeta() { }

        constexpr static const std::uint32_t field_count = 5;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 20; // 0x14
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16
        };
        constexpr static const char field_types[] = "niisi";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "ResearchSite.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ResearchProjectMeta : public DBMeta<ResearchProjectMeta> {
        constexpr ResearchProjectMeta() { }

        constexpr static const std::uint32_t field_count = 9;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 36; // 0x24
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24,  28,  32
        };
        constexpr static const char field_types[] = "nssiiiisi";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "ResearchProject.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ResearchFieldMeta : public DBMeta<ResearchFieldMeta> {
        constexpr ResearchFieldMeta() { }

        constexpr static const std::uint32_t field_count = 3;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 12; // 0xC
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8
        };
        constexpr static const char field_types[] = "nsi";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "ResearchField.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ResearchBranchMeta : public DBMeta<ResearchBranchMeta> {
        constexpr ResearchBranchMeta() { }

        constexpr static const std::uint32_t field_count = 6;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 24; // 0x18
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20
        };
        constexpr static const char field_types[] = "nsiisi";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "ResearchBranch.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct QuestXPMeta : public DBMeta<QuestXPMeta> {
        constexpr QuestXPMeta() { }

        constexpr static const std::uint32_t field_count = 2;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 44; // 0x2C
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4
        };
        constexpr static const char field_types[] = "ni";
        constexpr static const std::uint32_t array_sizes[] = {
            1,  10
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "QuestXP.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct QuestSortMeta : public DBMeta<QuestSortMeta> {
        constexpr QuestSortMeta() { }

        constexpr static const std::uint32_t field_count = 2;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 8; // 0x8
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4
        };
        constexpr static const char field_types[] = "ns";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "QuestSort.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct QuestPOIPointMeta : public DBMeta<QuestPOIPointMeta> {
        constexpr QuestPOIPointMeta() { }

        constexpr static const std::uint32_t field_count = 4;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 16; // 0x10
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12
        };
        constexpr static const char field_types[] = "niii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "QuestPOIPoint.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct QuestPOIBlobMeta : public DBMeta<QuestPOIBlobMeta> {
        constexpr QuestPOIBlobMeta() { }

        constexpr static const std::uint32_t field_count = 4;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 16; // 0x10
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12
        };
        constexpr static const char field_types[] = "niii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "QuestPOIBlob.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct QuestInfoMeta : public DBMeta<QuestInfoMeta> {
        constexpr QuestInfoMeta() { }

        constexpr static const std::uint32_t field_count = 2;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 8; // 0x8
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4
        };
        constexpr static const char field_types[] = "ns";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "QuestInfo.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct QuestFactionRewardMeta : public DBMeta<QuestFactionRewardMeta> {
        constexpr QuestFactionRewardMeta() { }

        constexpr static const std::uint32_t field_count = 2;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 44; // 0x2C
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4
        };
        constexpr static const char field_types[] = "ni";
        constexpr static const std::uint32_t array_sizes[] = {
            1,  10
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "QuestFactionReward.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct PvpDifficultyMeta : public DBMeta<PvpDifficultyMeta> {
        constexpr PvpDifficultyMeta() { }

        constexpr static const std::uint32_t field_count = 6;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 24; // 0x18
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20
        };
        constexpr static const char field_types[] = "niiiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "PvpDifficulty.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct PowerDisplayMeta : public DBMeta<PowerDisplayMeta> {
        constexpr PowerDisplayMeta() { }

        constexpr static const std::uint32_t field_count = 6;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 16; // 0x10
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  13,  14
        };
        constexpr static const char field_types[] = "nisiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   0,   0,   0
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "PowerDisplay.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct PlayerConditionMeta : public DBMeta<PlayerConditionMeta> {
        constexpr PlayerConditionMeta() { }

        constexpr static const std::uint32_t field_count = 2;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 8; // 0x8
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4
        };
        constexpr static const char field_types[] = "ns";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "PlayerCondition.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct PhaseXPhaseGroupMeta : public DBMeta<PhaseXPhaseGroupMeta> {
        constexpr PhaseXPhaseGroupMeta() { }

        constexpr static const std::uint32_t field_count = 3;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 12; // 0xC
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8
        };
        constexpr static const char field_types[] = "nii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "PhaseXPhaseGroup.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct PhaseMeta : public DBMeta<PhaseMeta> {
        constexpr PhaseMeta() { }

        constexpr static const std::uint32_t field_count = 3;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 12; // 0xC
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8
        };
        constexpr static const char field_types[] = "nsi";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "Phase.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct PaperDollItemFrameMeta : public DBMeta<PaperDollItemFrameMeta> {
        constexpr PaperDollItemFrameMeta() { }

        constexpr static const std::uint32_t field_count = 3;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 16; // 0x10
        constexpr static const std::uint32_t field_offsets[] = {
            4,   8,  12
        };
        constexpr static const char field_types[] = "nsi";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "PaperDollItemFrame.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct PageTextMaterialMeta : public DBMeta<PageTextMaterialMeta> {
        constexpr PageTextMaterialMeta() { }

        constexpr static const std::uint32_t field_count = 2;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 8; // 0x8
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4
        };
        constexpr static const char field_types[] = "ns";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "PageTextMaterial.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct PackageMeta : public DBMeta<PackageMeta> {
        constexpr PackageMeta() { }

        constexpr static const std::uint32_t field_count = 4;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 16; // 0x10
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12
        };
        constexpr static const char field_types[] = "nsis";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "Package.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct OverrideSpellDataMeta : public DBMeta<OverrideSpellDataMeta> {
        constexpr OverrideSpellDataMeta() { }

        constexpr static const std::uint32_t field_count = 4;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 52; // 0x34
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,  44,  48
        };
        constexpr static const char field_types[] = "niis";
        constexpr static const std::uint32_t array_sizes[] = {
            1,  10,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "OverrideSpellData.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct NumTalentsAtLevelMeta : public DBMeta<NumTalentsAtLevelMeta> {
        constexpr NumTalentsAtLevelMeta() { }

        constexpr static const std::uint32_t field_count = 2;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 8; // 0x8
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4
        };
        constexpr static const char field_types[] = "nf";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "NumTalentsAtLevel.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct NPCSoundsMeta : public DBMeta<NPCSoundsMeta> {
        constexpr NPCSoundsMeta() { }

        constexpr static const std::uint32_t field_count = 2;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 20; // 0x14
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4
        };
        constexpr static const char field_types[] = "ni";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   4
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "NPCSounds.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct MountTypeMeta : public DBMeta<MountTypeMeta> {
        constexpr MountTypeMeta() { }

        constexpr static const std::uint32_t field_count = 2;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 100; // 0x64
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4
        };
        constexpr static const char field_types[] = "ni";
        constexpr static const std::uint32_t array_sizes[] = {
            1,  24
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "MountType.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct MountCapabilityMeta : public DBMeta<MountCapabilityMeta> {
        constexpr MountCapabilityMeta() { }

        constexpr static const std::uint32_t field_count = 8;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 32; // 0x20
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24,  28
        };
        constexpr static const char field_types[] = "niiiiiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "MountCapability.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct MaterialMeta : public DBMeta<MaterialMeta> {
        constexpr MaterialMeta() { }

        constexpr static const std::uint32_t field_count = 5;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 20; // 0x14
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16
        };
        constexpr static const char field_types[] = "niiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "Material.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct MapDifficultyMeta : public DBMeta<MapDifficultyMeta> {
        constexpr MapDifficultyMeta() { }

        constexpr static const std::uint32_t field_count = 7;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 28; // 0x1C
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24
        };
        constexpr static const char field_types[] = "niisiis";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "MapDifficulty.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct MailTemplateMeta : public DBMeta<MailTemplateMeta> {
        constexpr MailTemplateMeta() { }

        constexpr static const std::uint32_t field_count = 3;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 12; // 0xC
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8
        };
        constexpr static const char field_types[] = "nss";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "MailTemplate.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct LockTypeMeta : public DBMeta<LockTypeMeta> {
        constexpr LockTypeMeta() { }

        constexpr static const std::uint32_t field_count = 5;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 20; // 0x14
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16
        };
        constexpr static const char field_types[] = "nssss";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "LockType.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct LockMeta : public DBMeta<LockMeta> {
        constexpr LockMeta() { }

        constexpr static const std::uint32_t field_count = 5;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 132; // 0x84
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,  36,  68, 100
        };
        constexpr static const char field_types[] = "niiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   8,   8,   8,   8
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "Lock.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct LoadingScreenTaxiSplinesMeta : public DBMeta<LoadingScreenTaxiSplinesMeta> {
        constexpr LoadingScreenTaxiSplinesMeta() { }

        constexpr static const std::uint32_t field_count = 5;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 76; // 0x4C
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  40,  72
        };
        constexpr static const char field_types[] = "niffi";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   8,   8,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "LoadingScreenTaxiSplines.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct LfgDungeonsMeta : public DBMeta<LfgDungeonsMeta> {
        constexpr LfgDungeonsMeta() { }

        constexpr static const std::uint32_t field_count = 21;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 84; // 0x54
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24,  28,  32,  36,
            40,  44,  48,  52,  56,  60,  64,  68,  72,  76,
            80
        };
        constexpr static const char field_types[] = "nsiiiiiiiiiisiiisiiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
            1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
            1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "LfgDungeons.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct LfgDungeonsGroupingMapMeta : public DBMeta<LfgDungeonsGroupingMapMeta> {
        constexpr LfgDungeonsGroupingMapMeta() { }

        constexpr static const std::uint32_t field_count = 4;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 16; // 0x10
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12
        };
        constexpr static const char field_types[] = "niii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "LfgDungeonsGroupingMap.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct LfgDungeonGroupMeta : public DBMeta<LfgDungeonGroupMeta> {
        constexpr LfgDungeonGroupMeta() { }

        constexpr static const std::uint32_t field_count = 5;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 20; // 0x14
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16
        };
        constexpr static const char field_types[] = "nsiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "LfgDungeonGroup.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct LfgDungeonExpansionMeta : public DBMeta<LfgDungeonExpansionMeta> {
        constexpr LfgDungeonExpansionMeta() { }

        constexpr static const std::uint32_t field_count = 8;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 32; // 0x20
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24,  28
        };
        constexpr static const char field_types[] = "niiiiiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "LfgDungeonExpansion.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct LanguagesMeta : public DBMeta<LanguagesMeta> {
        constexpr LanguagesMeta() { }

        constexpr static const std::uint32_t field_count = 2;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 8; // 0x8
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4
        };
        constexpr static const char field_types[] = "ns";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "Languages.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct LanguageWordsMeta : public DBMeta<LanguageWordsMeta> {
        constexpr LanguageWordsMeta() { }

        constexpr static const std::uint32_t field_count = 3;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 12; // 0xC
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8
        };
        constexpr static const char field_types[] = "nis";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "LanguageWords.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct JournalInstanceMeta : public DBMeta<JournalInstanceMeta> {
        constexpr JournalInstanceMeta() { }

        constexpr static const std::uint32_t field_count = 9;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 36; // 0x24
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24,  28,  32
        };
        constexpr static const char field_types[] = "niiiiiiss";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "JournalInstance.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct JournalEncounterSectionMeta : public DBMeta<JournalEncounterSectionMeta> {
        constexpr JournalEncounterSectionMeta() { }

        constexpr static const std::uint32_t field_count = 14;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 56; // 0x38
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24,  28,  32,  36,
            40,  44,  48,  52
        };
        constexpr static const char field_types[] = "niiiiiiiissiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
            1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "JournalEncounterSection.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct JournalEncounterMeta : public DBMeta<JournalEncounterMeta> {
        constexpr JournalEncounterMeta() { }

        constexpr static const std::uint32_t field_count = 10;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 44; // 0x2C
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  20,  24,  28,  32,  36,  40

        };
        constexpr static const char field_types[] = "niifiiiiss";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   2,   1,   1,   1,   1,   1,   1

        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "JournalEncounter.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct JournalEncounterItemMeta : public DBMeta<JournalEncounterItemMeta> {
        constexpr JournalEncounterItemMeta() { }

        constexpr static const std::uint32_t field_count = 5;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 20; // 0x14
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16
        };
        constexpr static const char field_types[] = "niiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "JournalEncounterItem.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct JournalEncounterCreatureMeta : public DBMeta<JournalEncounterCreatureMeta> {
        constexpr JournalEncounterCreatureMeta() { }

        constexpr static const std::uint32_t field_count = 7;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 28; // 0x1C
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24
        };
        constexpr static const char field_types[] = "niiiiss";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "JournalEncounterCreature.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ItemSubClassMaskMeta : public DBMeta<ItemSubClassMaskMeta> {
        constexpr ItemSubClassMaskMeta() { }

        constexpr static const std::uint32_t field_count = 3;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 16; // 0x10
        constexpr static const std::uint32_t field_offsets[] = {
            4,   8,  12
        };
        constexpr static const char field_types[] = "nis";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "ItemSubClassMask.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ItemSetMeta : public DBMeta<ItemSetMeta> {
        constexpr ItemSetMeta() { }

        constexpr static const std::uint32_t field_count = 7;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 148; // 0x94
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  76, 108, 140, 144
        };
        constexpr static const char field_types[] = "nsiiiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,  17,   8,   8,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "ItemSet.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ItemReforgeMeta : public DBMeta<ItemReforgeMeta> {
        constexpr ItemReforgeMeta() { }

        constexpr static const std::uint32_t field_count = 5;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 20; // 0x14
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16
        };
        constexpr static const char field_types[] = "nifif";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "ItemReforge.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ItemRandomSuffixMeta : public DBMeta<ItemRandomSuffixMeta> {
        constexpr ItemRandomSuffixMeta() { }

        constexpr static const std::uint32_t field_count = 5;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 52; // 0x34
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  32
        };
        constexpr static const char field_types[] = "nssii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   5,   5
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "ItemRandomSuffix.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ItemRandomPropertiesMeta : public DBMeta<ItemRandomPropertiesMeta> {
        constexpr ItemRandomPropertiesMeta() { }

        constexpr static const std::uint32_t field_count = 4;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 32; // 0x20
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  28
        };
        constexpr static const char field_types[] = "nsis";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   5,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "ItemRandomProperties.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ItemPurchaseGroupMeta : public DBMeta<ItemPurchaseGroupMeta> {
        constexpr ItemPurchaseGroupMeta() { }

        constexpr static const std::uint32_t field_count = 3;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 40; // 0x28
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,  36
        };
        constexpr static const char field_types[] = "nis";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   8,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "ItemPurchaseGroup.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ItemPriceBaseMeta : public DBMeta<ItemPriceBaseMeta> {
        constexpr ItemPriceBaseMeta() { }

        constexpr static const std::uint32_t field_count = 4;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 16; // 0x10
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12
        };
        constexpr static const char field_types[] = "niff";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "ItemPriceBase.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ItemPetFoodMeta : public DBMeta<ItemPetFoodMeta> {
        constexpr ItemPetFoodMeta() { }

        constexpr static const std::uint32_t field_count = 2;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 8; // 0x8
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4
        };
        constexpr static const char field_types[] = "ns";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "ItemPetFood.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ItemNameDescriptionMeta : public DBMeta<ItemNameDescriptionMeta> {
        constexpr ItemNameDescriptionMeta() { }

        constexpr static const std::uint32_t field_count = 3;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 12; // 0xC
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8
        };
        constexpr static const char field_types[] = "nsi";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "ItemNameDescription.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ItemLimitCategoryMeta : public DBMeta<ItemLimitCategoryMeta> {
        constexpr ItemLimitCategoryMeta() { }

        constexpr static const std::uint32_t field_count = 4;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 16; // 0x10
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12
        };
        constexpr static const char field_types[] = "nsii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "ItemLimitCategory.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ItemGroupSoundsMeta : public DBMeta<ItemGroupSoundsMeta> {
        constexpr ItemGroupSoundsMeta() { }

        constexpr static const std::uint32_t field_count = 2;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 20; // 0x14
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4
        };
        constexpr static const char field_types[] = "ni";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   4
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "ItemGroupSounds.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ItemDisenchantLootMeta : public DBMeta<ItemDisenchantLootMeta> {
        constexpr ItemDisenchantLootMeta() { }

        constexpr static const std::uint32_t field_count = 7;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 28; // 0x1C
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24
        };
        constexpr static const char field_types[] = "niiiiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "ItemDisenchantLoot.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ItemDamageWandMeta : public DBMeta<ItemDamageWandMeta> {
        constexpr ItemDamageWandMeta() { }

        constexpr static const std::uint32_t field_count = 3;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 36; // 0x24
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,  32
        };
        constexpr static const char field_types[] = "nfi";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   7,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "ItemDamageWand.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ItemDamageTwoHandCasterMeta : public DBMeta<ItemDamageTwoHandCasterMeta> {
        constexpr ItemDamageTwoHandCasterMeta() { }

        constexpr static const std::uint32_t field_count = 3;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 36; // 0x24
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,  32
        };
        constexpr static const char field_types[] = "nfi";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   7,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "ItemDamageTwoHandCaster.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ItemDamageTwoHandMeta : public DBMeta<ItemDamageTwoHandMeta> {
        constexpr ItemDamageTwoHandMeta() { }

        constexpr static const std::uint32_t field_count = 3;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 36; // 0x24
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,  32
        };
        constexpr static const char field_types[] = "nfi";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   7,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "ItemDamageTwoHand.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ItemDamageThrownMeta : public DBMeta<ItemDamageThrownMeta> {
        constexpr ItemDamageThrownMeta() { }

        constexpr static const std::uint32_t field_count = 3;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 36; // 0x24
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,  32
        };
        constexpr static const char field_types[] = "nfi";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   7,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "ItemDamageThrown.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ItemDamageRangedMeta : public DBMeta<ItemDamageRangedMeta> {
        constexpr ItemDamageRangedMeta() { }

        constexpr static const std::uint32_t field_count = 3;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 36; // 0x24
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,  32
        };
        constexpr static const char field_types[] = "nfi";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   7,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "ItemDamageRanged.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ItemDamageOneHandCasterMeta : public DBMeta<ItemDamageOneHandCasterMeta> {
        constexpr ItemDamageOneHandCasterMeta() { }

        constexpr static const std::uint32_t field_count = 3;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 36; // 0x24
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,  32
        };
        constexpr static const char field_types[] = "nfi";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   7,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "ItemDamageOneHandCaster.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ItemDamageOneHandMeta : public DBMeta<ItemDamageOneHandMeta> {
        constexpr ItemDamageOneHandMeta() { }

        constexpr static const std::uint32_t field_count = 3;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 36; // 0x24
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,  32
        };
        constexpr static const char field_types[] = "nfi";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   7,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "ItemDamageOneHand.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ItemDamageAmmoMeta : public DBMeta<ItemDamageAmmoMeta> {
        constexpr ItemDamageAmmoMeta() { }

        constexpr static const std::uint32_t field_count = 3;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 36; // 0x24
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,  32
        };
        constexpr static const char field_types[] = "nfi";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   7,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "ItemDamageAmmo.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ItemBagFamilyMeta : public DBMeta<ItemBagFamilyMeta> {
        constexpr ItemBagFamilyMeta() { }

        constexpr static const std::uint32_t field_count = 2;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 8; // 0x8
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4
        };
        constexpr static const char field_types[] = "ns";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "ItemBagFamily.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ItemArmorShieldMeta : public DBMeta<ItemArmorShieldMeta> {
        constexpr ItemArmorShieldMeta() { }

        constexpr static const std::uint32_t field_count = 3;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 36; // 0x24
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8
        };
        constexpr static const char field_types[] = "nif";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   7
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "ItemArmorShield.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ItemArmorTotalMeta : public DBMeta<ItemArmorTotalMeta> {
        constexpr ItemArmorTotalMeta() { }

        constexpr static const std::uint32_t field_count = 6;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 24; // 0x18
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20
        };
        constexpr static const char field_types[] = "niffff";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "ItemArmorTotal.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ItemArmorQualityMeta : public DBMeta<ItemArmorQualityMeta> {
        constexpr ItemArmorQualityMeta() { }

        constexpr static const std::uint32_t field_count = 3;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 36; // 0x24
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,  32
        };
        constexpr static const char field_types[] = "nfi";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   7,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "ItemArmorQuality.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ImportPriceWeaponMeta : public DBMeta<ImportPriceWeaponMeta> {
        constexpr ImportPriceWeaponMeta() { }

        constexpr static const std::uint32_t field_count = 2;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 8; // 0x8
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4
        };
        constexpr static const char field_types[] = "nf";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "ImportPriceWeapon.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ImportPriceShieldMeta : public DBMeta<ImportPriceShieldMeta> {
        constexpr ImportPriceShieldMeta() { }

        constexpr static const std::uint32_t field_count = 2;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 8; // 0x8
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4
        };
        constexpr static const char field_types[] = "nf";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "ImportPriceShield.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ImportPriceQualityMeta : public DBMeta<ImportPriceQualityMeta> {
        constexpr ImportPriceQualityMeta() { }

        constexpr static const std::uint32_t field_count = 2;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 8; // 0x8
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4
        };
        constexpr static const char field_types[] = "nf";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "ImportPriceQuality.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ImportPriceArmorMeta : public DBMeta<ImportPriceArmorMeta> {
        constexpr ImportPriceArmorMeta() { }

        constexpr static const std::uint32_t field_count = 5;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 20; // 0x14
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16
        };
        constexpr static const char field_types[] = "nffff";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "ImportPriceArmor.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct HolidaysMeta : public DBMeta<HolidaysMeta> {
        constexpr HolidaysMeta() { }

        constexpr static const std::uint32_t field_count = 12;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 220; // 0xDC
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,  44, 148, 152, 156, 196, 200, 204, 208,
            212, 216
        };
        constexpr static const char field_types[] = "niiiiiiisiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,  10,  26,   1,   1,  10,   1,   1,   1,   1,
            1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "Holidays.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct HolidayNamesMeta : public DBMeta<HolidayNamesMeta> {
        constexpr HolidayNamesMeta() { }

        constexpr static const std::uint32_t field_count = 2;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 8; // 0x8
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4
        };
        constexpr static const char field_types[] = "ns";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "HolidayNames.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct HolidayDescriptionsMeta : public DBMeta<HolidayDescriptionsMeta> {
        constexpr HolidayDescriptionsMeta() { }

        constexpr static const std::uint32_t field_count = 2;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 8; // 0x8
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4
        };
        constexpr static const char field_types[] = "ns";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "HolidayDescriptions.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct GuildPerkSpellsMeta : public DBMeta<GuildPerkSpellsMeta> {
        constexpr GuildPerkSpellsMeta() { }

        constexpr static const std::uint32_t field_count = 3;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 12; // 0xC
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8
        };
        constexpr static const char field_types[] = "nii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "GuildPerkSpells.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct gtSpellScalingMeta : public DBMeta<gtSpellScalingMeta> {
        constexpr gtSpellScalingMeta() { }

        constexpr static const std::uint32_t field_count = 1;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 8; // 0x8
        constexpr static const std::uint32_t field_offsets[] = {
            4
        };
        constexpr static const char field_types[] = "n";
        constexpr static const std::uint32_t array_sizes[] = {
            1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "gtSpellScaling.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct gtRegenMPPerSptMeta : public DBMeta<gtRegenMPPerSptMeta> {
        constexpr gtRegenMPPerSptMeta() { }

        constexpr static const std::uint32_t field_count = 1;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 8; // 0x8
        constexpr static const std::uint32_t field_offsets[] = {
            4
        };
        constexpr static const char field_types[] = "n";
        constexpr static const std::uint32_t array_sizes[] = {
            1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "gtRegenMPPerSpt.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct gtOCTRegenMPMeta : public DBMeta<gtOCTRegenMPMeta> {
        constexpr gtOCTRegenMPMeta() { }

        constexpr static const std::uint32_t field_count = 1;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 8; // 0x8
        constexpr static const std::uint32_t field_offsets[] = {
            4
        };
        constexpr static const char field_types[] = "n";
        constexpr static const std::uint32_t array_sizes[] = {
            1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "gtOCTRegenMP.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct gtOCTHpPerStaminaMeta : public DBMeta<gtOCTHpPerStaminaMeta> {
        constexpr gtOCTHpPerStaminaMeta() { }

        constexpr static const std::uint32_t field_count = 1;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 8; // 0x8
        constexpr static const std::uint32_t field_offsets[] = {
            4
        };
        constexpr static const char field_types[] = "n";
        constexpr static const std::uint32_t array_sizes[] = {
            1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "gtOCTHpPerStamina.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct gtOCTClassCombatRatingScalarMeta : public DBMeta<gtOCTClassCombatRatingScalarMeta> {
        constexpr gtOCTClassCombatRatingScalarMeta() { }

        constexpr static const std::uint32_t field_count = 2;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 8; // 0x8
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4
        };
        constexpr static const char field_types[] = "nf";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "gtOCTClassCombatRatingScalar.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct gtOCTBaseMPByClassMeta : public DBMeta<gtOCTBaseMPByClassMeta> {
        constexpr gtOCTBaseMPByClassMeta() { }

        constexpr static const std::uint32_t field_count = 1;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 8; // 0x8
        constexpr static const std::uint32_t field_offsets[] = {
            4
        };
        constexpr static const char field_types[] = "n";
        constexpr static const std::uint32_t array_sizes[] = {
            1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "gtOCTBaseMPByClass.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct gtOCTBaseHPByClassMeta : public DBMeta<gtOCTBaseHPByClassMeta> {
        constexpr gtOCTBaseHPByClassMeta() { }

        constexpr static const std::uint32_t field_count = 1;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 8; // 0x8
        constexpr static const std::uint32_t field_offsets[] = {
            4
        };
        constexpr static const char field_types[] = "n";
        constexpr static const std::uint32_t array_sizes[] = {
            1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "gtOCTBaseHPByClass.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct gtNPCManaCostScalerMeta : public DBMeta<gtNPCManaCostScalerMeta> {
        constexpr gtNPCManaCostScalerMeta() { }

        constexpr static const std::uint32_t field_count = 1;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 8; // 0x8
        constexpr static const std::uint32_t field_offsets[] = {
            4
        };
        constexpr static const char field_types[] = "n";
        constexpr static const std::uint32_t array_sizes[] = {
            1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "gtNPCManaCostScaler.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct gtChanceToSpellCritBaseMeta : public DBMeta<gtChanceToSpellCritBaseMeta> {
        constexpr gtChanceToSpellCritBaseMeta() { }

        constexpr static const std::uint32_t field_count = 1;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 8; // 0x8
        constexpr static const std::uint32_t field_offsets[] = {
            4
        };
        constexpr static const char field_types[] = "n";
        constexpr static const std::uint32_t array_sizes[] = {
            1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "gtChanceToSpellCritBase.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct gtChanceToSpellCritMeta : public DBMeta<gtChanceToSpellCritMeta> {
        constexpr gtChanceToSpellCritMeta() { }

        constexpr static const std::uint32_t field_count = 1;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 8; // 0x8
        constexpr static const std::uint32_t field_offsets[] = {
            4
        };
        constexpr static const char field_types[] = "n";
        constexpr static const std::uint32_t array_sizes[] = {
            1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "gtChanceToSpellCrit.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct gtChanceToMeleeCritBaseMeta : public DBMeta<gtChanceToMeleeCritBaseMeta> {
        constexpr gtChanceToMeleeCritBaseMeta() { }

        constexpr static const std::uint32_t field_count = 1;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 8; // 0x8
        constexpr static const std::uint32_t field_offsets[] = {
            4
        };
        constexpr static const char field_types[] = "n";
        constexpr static const std::uint32_t array_sizes[] = {
            1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "gtChanceToMeleeCritBase.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct gtChanceToMeleeCritMeta : public DBMeta<gtChanceToMeleeCritMeta> {
        constexpr gtChanceToMeleeCritMeta() { }

        constexpr static const std::uint32_t field_count = 1;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 8; // 0x8
        constexpr static const std::uint32_t field_offsets[] = {
            4
        };
        constexpr static const char field_types[] = "n";
        constexpr static const std::uint32_t array_sizes[] = {
            1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "gtChanceToMeleeCrit.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct gtCombatRatingsMeta : public DBMeta<gtCombatRatingsMeta> {
        constexpr gtCombatRatingsMeta() { }

        constexpr static const std::uint32_t field_count = 1;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 8; // 0x8
        constexpr static const std::uint32_t field_offsets[] = {
            4
        };
        constexpr static const char field_types[] = "n";
        constexpr static const std::uint32_t array_sizes[] = {
            1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "gtCombatRatings.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct gtBarberShopCostBaseMeta : public DBMeta<gtBarberShopCostBaseMeta> {
        constexpr gtBarberShopCostBaseMeta() { }

        constexpr static const std::uint32_t field_count = 1;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 8; // 0x8
        constexpr static const std::uint32_t field_offsets[] = {
            4
        };
        constexpr static const char field_types[] = "n";
        constexpr static const std::uint32_t array_sizes[] = {
            1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "gtBarberShopCostBase.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct GMTicketCategoryMeta : public DBMeta<GMTicketCategoryMeta> {
        constexpr GMTicketCategoryMeta() { }

        constexpr static const std::uint32_t field_count = 2;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 8; // 0x8
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4
        };
        constexpr static const char field_types[] = "ns";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "GMTicketCategory.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct GMSurveySurveysMeta : public DBMeta<GMSurveySurveysMeta> {
        constexpr GMSurveySurveysMeta() { }

        constexpr static const std::uint32_t field_count = 2;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 64; // 0x40
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4
        };
        constexpr static const char field_types[] = "ni";
        constexpr static const std::uint32_t array_sizes[] = {
            1,  15
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "GMSurveySurveys.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct GMSurveyQuestionsMeta : public DBMeta<GMSurveyQuestionsMeta> {
        constexpr GMSurveyQuestionsMeta() { }

        constexpr static const std::uint32_t field_count = 2;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 8; // 0x8
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4
        };
        constexpr static const char field_types[] = "ns";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "GMSurveyQuestions.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct GMSurveyCurrentSurveyMeta : public DBMeta<GMSurveyCurrentSurveyMeta> {
        constexpr GMSurveyCurrentSurveyMeta() { }

        constexpr static const std::uint32_t field_count = 2;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 8; // 0x8
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4
        };
        constexpr static const char field_types[] = "ni";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "GMSurveyCurrentSurvey.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct GMSurveyAnswersMeta : public DBMeta<GMSurveyAnswersMeta> {
        constexpr GMSurveyAnswersMeta() { }

        constexpr static const std::uint32_t field_count = 4;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 16; // 0x10
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12
        };
        constexpr static const char field_types[] = "niis";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "GMSurveyAnswers.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct GlyphSlotMeta : public DBMeta<GlyphSlotMeta> {
        constexpr GlyphSlotMeta() { }

        constexpr static const std::uint32_t field_count = 3;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 12; // 0xC
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8
        };
        constexpr static const char field_types[] = "nii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "GlyphSlot.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct GlyphPropertiesMeta : public DBMeta<GlyphPropertiesMeta> {
        constexpr GlyphPropertiesMeta() { }

        constexpr static const std::uint32_t field_count = 4;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 16; // 0x10
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12
        };
        constexpr static const char field_types[] = "niii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "GlyphProperties.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct GemPropertiesMeta : public DBMeta<GemPropertiesMeta> {
        constexpr GemPropertiesMeta() { }

        constexpr static const std::uint32_t field_count = 6;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 24; // 0x18
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20
        };
        constexpr static const char field_types[] = "niiiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "GemProperties.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct GameTablesMeta : public DBMeta<GameTablesMeta> {
        constexpr GameTablesMeta() { }

        constexpr static const std::uint32_t field_count = 3;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 16; // 0x10
        constexpr static const std::uint32_t field_offsets[] = {
            4,   8,  12
        };
        constexpr static const char field_types[] = "nii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "GameTables.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct GameObjectDisplayInfoMeta : public DBMeta<GameObjectDisplayInfoMeta> {
        constexpr GameObjectDisplayInfoMeta() { }

        constexpr static const std::uint32_t field_count = 8;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 84; // 0x54
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  48,  60,  72,  76,  80
        };
        constexpr static const char field_types[] = "nsiffiff";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,  10,   3,   3,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "GameObjectDisplayInfo.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct GameObjectArtKitMeta : public DBMeta<GameObjectArtKitMeta> {
        constexpr GameObjectArtKitMeta() { }

        constexpr static const std::uint32_t field_count = 3;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 32; // 0x20
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,  16
        };
        constexpr static const char field_types[] = "nss";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   3,   4
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "GameObjectArtKit.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct FootstepTerrainLookupMeta : public DBMeta<FootstepTerrainLookupMeta> {
        constexpr FootstepTerrainLookupMeta() { }

        constexpr static const std::uint32_t field_count = 5;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 20; // 0x14
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16
        };
        constexpr static const char field_types[] = "niiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "FootstepTerrainLookup.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct FactionMeta : public DBMeta<FactionMeta> {
        constexpr FactionMeta() { }

        constexpr static const std::uint32_t field_count = 12;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 104; // 0x68
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  24,  40,  56,  72,  76,  84,  92,
            96, 100
        };
        constexpr static const char field_types[] = "niiiiiifissi";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   4,   4,   4,   4,   1,   2,   2,   1,
            1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "Faction.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ExhaustionMeta : public DBMeta<ExhaustionMeta> {
        constexpr ExhaustionMeta() { }

        constexpr static const std::uint32_t field_count = 7;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 28; // 0x1C
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24
        };
        constexpr static const char field_types[] = "nifffsf";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "Exhaustion.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct EnvironmentalDamageMeta : public DBMeta<EnvironmentalDamageMeta> {
        constexpr EnvironmentalDamageMeta() { }

        constexpr static const std::uint32_t field_count = 3;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 12; // 0xC
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8
        };
        constexpr static const char field_types[] = "nii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "EnvironmentalDamage.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct EmotesTextMeta : public DBMeta<EmotesTextMeta> {
        constexpr EmotesTextMeta() { }

        constexpr static const std::uint32_t field_count = 4;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 76; // 0x4C
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12
        };
        constexpr static const char field_types[] = "nsii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,  16
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "EmotesText.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct EmotesTextSoundMeta : public DBMeta<EmotesTextSoundMeta> {
        constexpr EmotesTextSoundMeta() { }

        constexpr static const std::uint32_t field_count = 5;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 20; // 0x14
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16
        };
        constexpr static const char field_types[] = "niiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "EmotesTextSound.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct EmotesTextDataMeta : public DBMeta<EmotesTextDataMeta> {
        constexpr EmotesTextDataMeta() { }

        constexpr static const std::uint32_t field_count = 2;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 8; // 0x8
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4
        };
        constexpr static const char field_types[] = "ns";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "EmotesTextData.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct EmotesMeta : public DBMeta<EmotesMeta> {
        constexpr EmotesMeta() { }

        constexpr static const std::uint32_t field_count = 8;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 32; // 0x20
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24,  28
        };
        constexpr static const char field_types[] = "nsiiiiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "Emotes.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct DurabilityQualityMeta : public DBMeta<DurabilityQualityMeta> {
        constexpr DurabilityQualityMeta() { }

        constexpr static const std::uint32_t field_count = 2;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 8; // 0x8
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4
        };
        constexpr static const char field_types[] = "nf";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "DurabilityQuality.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct DurabilityCostsMeta : public DBMeta<DurabilityCostsMeta> {
        constexpr DurabilityCostsMeta() { }

        constexpr static const std::uint32_t field_count = 3;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 120; // 0x78
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,  88
        };
        constexpr static const char field_types[] = "nii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,  21,   8
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "DurabilityCosts.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct DungeonMapChunkMeta : public DBMeta<DungeonMapChunkMeta> {
        constexpr DungeonMapChunkMeta() { }

        constexpr static const std::uint32_t field_count = 5;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 20; // 0x14
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16
        };
        constexpr static const char field_types[] = "niiif";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "DungeonMapChunk.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct DungeonMapMeta : public DBMeta<DungeonMapMeta> {
        constexpr DungeonMapMeta() { }

        constexpr static const std::uint32_t field_count = 6;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 32; // 0x20
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  20,  28
        };
        constexpr static const char field_types[] = "niiffi";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   2,   2,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "DungeonMap.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct DungeonEncounterMeta : public DBMeta<DungeonEncounterMeta> {
        constexpr DungeonEncounterMeta() { }

        constexpr static const std::uint32_t field_count = 8;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 32; // 0x20
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24,  28
        };
        constexpr static const char field_types[] = "niiiisii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "DungeonEncounter.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct DestructibleModelDataMeta : public DBMeta<DestructibleModelDataMeta> {
        constexpr DestructibleModelDataMeta() { }

        constexpr static const std::uint32_t field_count = 24;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 96; // 0x60
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24,  28,  32,  36,
            40,  44,  48,  52,  56,  60,  64,  68,  72,  76,
            80,  84,  88,  92
        };
        constexpr static const char field_types[] = "niiiiiiiiiiiiiiiiiiiiiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
            1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
            1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "DestructibleModelData.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct DeathThudLookupsMeta : public DBMeta<DeathThudLookupsMeta> {
        constexpr DeathThudLookupsMeta() { }

        constexpr static const std::uint32_t field_count = 5;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 20; // 0x14
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16
        };
        constexpr static const char field_types[] = "niiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "DeathThudLookups.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct DanceMovesMeta : public DBMeta<DanceMovesMeta> {
        constexpr DanceMovesMeta() { }

        constexpr static const std::uint32_t field_count = 8;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 32; // 0x20
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24,  28
        };
        constexpr static const char field_types[] = "niiiissi";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "DanceMoves.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct CurrencyCategoryMeta : public DBMeta<CurrencyCategoryMeta> {
        constexpr CurrencyCategoryMeta() { }

        constexpr static const std::uint32_t field_count = 3;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 12; // 0xC
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8
        };
        constexpr static const char field_types[] = "nis";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "CurrencyCategory.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct CurrencyTypesMeta : public DBMeta<CurrencyTypesMeta> {
        constexpr CurrencyTypesMeta() { }

        constexpr static const std::uint32_t field_count = 10;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 44; // 0x2C
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  20,  24,  28,  32,  36,  40

        };
        constexpr static const char field_types[] = "nissiiiiis";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   2,   1,   1,   1,   1,   1,   1

        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "CurrencyTypes.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct CreatureTypeMeta : public DBMeta<CreatureTypeMeta> {
        constexpr CreatureTypeMeta() { }

        constexpr static const std::uint32_t field_count = 3;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 12; // 0xC
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8
        };
        constexpr static const char field_types[] = "nsi";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "CreatureType.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct CreatureSpellDataMeta : public DBMeta<CreatureSpellDataMeta> {
        constexpr CreatureSpellDataMeta() { }

        constexpr static const std::uint32_t field_count = 3;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 36; // 0x24
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,  20
        };
        constexpr static const char field_types[] = "nii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   4,   4
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "CreatureSpellData.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct CreatureSoundDataMeta : public DBMeta<CreatureSoundDataMeta> {
        constexpr CreatureSoundDataMeta() { }

        constexpr static const std::uint32_t field_count = 33;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 160; // 0xA0
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24,  28,  32,  36,
            40,  44,  48,  52,  56,  76,  92,  96, 100, 104,
            108, 112, 116, 120, 124, 128, 132, 136, 140, 144,
            148, 152, 156
        };
        constexpr static const char field_types[] = "niiiiiiiiiiiiiiiiiiiiiiiffiiiiiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
            1,   1,   1,   1,   5,   4,   1,   1,   1,   1,
            1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
            1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "CreatureSoundData.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct CreatureMovementInfoMeta : public DBMeta<CreatureMovementInfoMeta> {
        constexpr CreatureMovementInfoMeta() { }

        constexpr static const std::uint32_t field_count = 2;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 8; // 0x8
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4
        };
        constexpr static const char field_types[] = "nf";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "CreatureMovementInfo.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct CreatureImmunitiesMeta : public DBMeta<CreatureImmunitiesMeta> {
        constexpr CreatureImmunitiesMeta() { }

        constexpr static const std::uint32_t field_count = 10;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 104; // 0x68
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24,  48,  52, 100

        };
        constexpr static const char field_types[] = "niiiiiiiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   6,   1,  12,   1

        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "CreatureImmunities.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct CinematicSequencesMeta : public DBMeta<CinematicSequencesMeta> {
        constexpr CinematicSequencesMeta() { }

        constexpr static const std::uint32_t field_count = 3;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 40; // 0x28
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8
        };
        constexpr static const char field_types[] = "nii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   8
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "CinematicSequences.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct CinematicCameraMeta : public DBMeta<CinematicCameraMeta> {
        constexpr CinematicCameraMeta() { }

        constexpr static const std::uint32_t field_count = 5;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 28; // 0x1C
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  24
        };
        constexpr static const char field_types[] = "nsiff";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   3,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "CinematicCamera.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ChrClassesXPowerTypesMeta : public DBMeta<ChrClassesXPowerTypesMeta> {
        constexpr ChrClassesXPowerTypesMeta() { }

        constexpr static const std::uint32_t field_count = 2;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 12; // 0xC
        constexpr static const std::uint32_t field_offsets[] = {
            4,   8
        };
        constexpr static const char field_types[] = "ni";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "ChrClassesXPowerTypes.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ChatChannelsMeta : public DBMeta<ChatChannelsMeta> {
        constexpr ChatChannelsMeta() { }

        constexpr static const std::uint32_t field_count = 5;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 20; // 0x14
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16
        };
        constexpr static const char field_types[] = "niiss";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "ChatChannels.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct CharTitlesMeta : public DBMeta<CharTitlesMeta> {
        constexpr CharTitlesMeta() { }

        constexpr static const std::uint32_t field_count = 6;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 24; // 0x18
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20
        };
        constexpr static const char field_types[] = "nissii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "CharTitles.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct CastableRaidBuffsMeta : public DBMeta<CastableRaidBuffsMeta> {
        constexpr CastableRaidBuffsMeta() { }

        constexpr static const std::uint32_t field_count = 3;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 12; // 0xC
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8
        };
        constexpr static const char field_types[] = "nii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "CastableRaidBuffs.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct CameraShakesMeta : public DBMeta<CameraShakesMeta> {
        constexpr CameraShakesMeta() { }

        constexpr static const std::uint32_t field_count = 9;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 36; // 0x24
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24,  28,  32
        };
        constexpr static const char field_types[] = "niifffffi";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "CameraShakes.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct CameraModeMeta : public DBMeta<CameraModeMeta> {
        constexpr CameraModeMeta() { }

        constexpr static const std::uint32_t field_count = 13;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 68; // 0x44
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  28,  40,  44,  48,  52,
            56,  60,  64
        };
        constexpr static const char field_types[] = "nsiifffffiiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   3,   3,   1,   1,   1,   1,
            1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "CameraMode.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct BattlemasterListMeta : public DBMeta<BattlemasterListMeta> {
        constexpr BattlemasterListMeta() { }

        constexpr static const std::uint32_t field_count = 13;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 80; // 0x50
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,  36,  40,  44,  48,  52,  56,  60,  64,
            68,  72,  76
        };
        constexpr static const char field_types[] = "niiisiiiiiiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   8,   1,   1,   1,   1,   1,   1,   1,   1,
            1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "BattlemasterList.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct BarberShopStyleMeta : public DBMeta<BarberShopStyleMeta> {
        constexpr BarberShopStyleMeta() { }

        constexpr static const std::uint32_t field_count = 8;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 32; // 0x20
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24,  28
        };
        constexpr static const char field_types[] = "nissfiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "BarberShopStyle.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct BankBagSlotPricesMeta : public DBMeta<BankBagSlotPricesMeta> {
        constexpr BankBagSlotPricesMeta() { }

        constexpr static const std::uint32_t field_count = 2;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 8; // 0x8
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4
        };
        constexpr static const char field_types[] = "ni";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "BankBagSlotPrices.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct AuctionHouseMeta : public DBMeta<AuctionHouseMeta> {
        constexpr AuctionHouseMeta() { }

        constexpr static const std::uint32_t field_count = 5;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 20; // 0x14
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16
        };
        constexpr static const char field_types[] = "niiis";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "AuctionHouse.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ArmorLocationMeta : public DBMeta<ArmorLocationMeta> {
        constexpr ArmorLocationMeta() { }

        constexpr static const std::uint32_t field_count = 6;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 24; // 0x18
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20
        };
        constexpr static const char field_types[] = "nfffff";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "ArmorLocation.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct AreaTriggerMeta : public DBMeta<AreaTriggerMeta> {
        constexpr AreaTriggerMeta() { }

        constexpr static const std::uint32_t field_count = 11;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 52; // 0x34
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  20,  24,  28,  32,  36,  40,  44,
            48
        };
        constexpr static const char field_types[] = "nifiiifffff";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   3,   1,   1,   1,   1,   1,   1,   1,
            1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "AreaTrigger.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct AreaAssignmentMeta : public DBMeta<AreaAssignmentMeta> {
        constexpr AreaAssignmentMeta() { }

        constexpr static const std::uint32_t field_count = 4;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 20; // 0x14
        constexpr static const std::uint32_t field_offsets[] = {
            4,   8,  12,  16
        };
        constexpr static const char field_types[] = "niii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "AreaAssignment.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct AreaPOISortedWorldStateMeta : public DBMeta<AreaPOISortedWorldStateMeta> {
        constexpr AreaPOISortedWorldStateMeta() { }

        constexpr static const std::uint32_t field_count = 3;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 12; // 0xC
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8
        };
        constexpr static const char field_types[] = "nii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "AreaPOISortedWorldState.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct AreaPOIMeta : public DBMeta<AreaPOIMeta> {
        constexpr AreaPOIMeta() { }

        constexpr static const std::uint32_t field_count = 13;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 88; // 0x58
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  44,  48,  56,  60,  64,  68,  72,
            76,  80,  84
        };
        constexpr static const char field_types[] = "niiifiiissiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   9,   1,   2,   1,   1,   1,   1,   1,
            1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "AreaPOI.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct AreaGroupMeta : public DBMeta<AreaGroupMeta> {
        constexpr AreaGroupMeta() { }

        constexpr static const std::uint32_t field_count = 3;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 32; // 0x20
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,  28
        };
        constexpr static const char field_types[] = "nii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   6,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "AreaGroup.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct Achievement_CategoryMeta : public DBMeta<Achievement_CategoryMeta> {
        constexpr Achievement_CategoryMeta() { }

        constexpr static const std::uint32_t field_count = 4;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 16; // 0x10
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12
        };
        constexpr static const char field_types[] = "nisi";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "Achievement_Category.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct Achievement_CriteriaMeta : public DBMeta<Achievement_CriteriaMeta> {
        constexpr Achievement_CriteriaMeta() { }

        constexpr static const std::uint32_t field_count = 19;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 96; // 0x60
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  24,  28,  32,  36,  40,
            44,  48,  52,  56,  60,  64,  68,  72,  84
        };
        constexpr static const char field_types[] = "niiiliiiisiiiiiiiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
            1,   1,   1,   1,   1,   1,   1,   3,   3
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "Achievement_Criteria.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct AchievementMeta : public DBMeta<AchievementMeta> {
        constexpr AchievementMeta() { }

        constexpr static const std::uint32_t field_count = 14;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 56; // 0x38
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24,  28,  32,  36,
            40,  44,  48,  52
        };
        constexpr static const char field_types[] = "niiissiiiiisii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
            1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "Achievement.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ItemCurrencyCostMeta : public DBMeta<ItemCurrencyCostMeta> {
        constexpr ItemCurrencyCostMeta() { }

        constexpr static const std::uint32_t field_count = 2;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 8; // 0x8
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4
        };
        constexpr static const char field_types[] = "ni";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1
        };
        constexpr static const bool sparse_storage = true;
        constexpr static const bool has_string = false;

        static const char* name() { return "ItemCurrencyCost.db2"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ItemExtendedCostMeta : public DBMeta<ItemExtendedCostMeta> {
        constexpr ItemExtendedCostMeta() { }

        constexpr static const std::uint32_t field_count = 15;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 124; // 0x7C
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  36,  56,  60,  64,  84,
            104, 108, 112, 116, 120
        };
        constexpr static const char field_types[] = "niiiiiiiiiiiiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   5,   5,   1,   1,   5,   5,
            1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = true;
        constexpr static const bool has_string = false;

        static const char* name() { return "ItemExtendedCost.db2"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct KeyChainMeta : public DBMeta<KeyChainMeta> {
        constexpr KeyChainMeta() { }

        constexpr static const std::uint32_t field_count = 2;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 36; // 0x24
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4
        };
        constexpr static const char field_types[] = "n4";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   8
        };
        constexpr static const bool sparse_storage = true;
        constexpr static const bool has_string = false;

        static const char* name() { return "KeyChain.db2"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct DeclinedWordCasesMeta : public DBMeta<DeclinedWordCasesMeta> {
        constexpr DeclinedWordCasesMeta() { }

        constexpr static const std::uint32_t field_count = 4;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 16; // 0x10
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12
        };
        constexpr static const char field_types[] = "niis";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "DeclinedWordCases.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct DeclinedWordMeta : public DBMeta<DeclinedWordMeta> {
        constexpr DeclinedWordMeta() { }

        constexpr static const std::uint32_t field_count = 2;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 8; // 0x8
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4
        };
        constexpr static const char field_types[] = "ns";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "DeclinedWord.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ZoneLightPointMeta : public DBMeta<ZoneLightPointMeta> {
        constexpr ZoneLightPointMeta() { }

        constexpr static const std::uint32_t field_count = 4;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 20; // 0x14
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  16
        };
        constexpr static const char field_types[] = "nifi";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   2,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "ZoneLightPoint.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct ZoneLightMeta : public DBMeta<ZoneLightMeta> {
        constexpr ZoneLightMeta() { }

        constexpr static const std::uint32_t field_count = 4;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 16; // 0x10
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12
        };
        constexpr static const char field_types[] = "nsii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "ZoneLight.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct WMOAreaTableMeta : public DBMeta<WMOAreaTableMeta> {
        constexpr WMOAreaTableMeta() { }

        constexpr static const std::uint32_t field_count = 15;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 60; // 0x3C
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24,  28,  32,  36,
            40,  44,  48,  52,  56
        };
        constexpr static const char field_types[] = "niiiiiiiiiisiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
            1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "WMOAreaTable.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct WeatherMeta : public DBMeta<WeatherMeta> {
        constexpr WeatherMeta() { }

        constexpr static const std::uint32_t field_count = 6;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 32; // 0x20
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  28
        };
        constexpr static const char field_types[] = "niiffs";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   3,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "Weather.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct TerrainTypeMeta : public DBMeta<TerrainTypeMeta> {
        constexpr TerrainTypeMeta() { }

        constexpr static const std::uint32_t field_count = 6;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 28; // 0x1C
        constexpr static const std::uint32_t field_offsets[] = {
            4,   8,  12,  16,  20,  24
        };
        constexpr static const char field_types[] = "nsiiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "TerrainType.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct TerrainMaterialMeta : public DBMeta<TerrainMaterialMeta> {
        constexpr TerrainMaterialMeta() { }

        constexpr static const std::uint32_t field_count = 4;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 16; // 0x10
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12
        };
        constexpr static const char field_types[] = "nsis";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "TerrainMaterial.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SoundEntriesFallbacksMeta : public DBMeta<SoundEntriesFallbacksMeta> {
        constexpr SoundEntriesFallbacksMeta() { }

        constexpr static const std::uint32_t field_count = 3;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 12; // 0xC
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8
        };
        constexpr static const char field_types[] = "nii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "SoundEntriesFallbacks.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SoundEmittersMeta : public DBMeta<SoundEmittersMeta> {
        constexpr SoundEmittersMeta() { }

        constexpr static const std::uint32_t field_count = 7;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 44; // 0x2C
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,  16,  28,  32,  36,  40
        };
        constexpr static const char field_types[] = "nffiisi";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   3,   3,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "SoundEmitters.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SoundEmitterPillPointsMeta : public DBMeta<SoundEmitterPillPointsMeta> {
        constexpr SoundEmitterPillPointsMeta() { }

        constexpr static const std::uint32_t field_count = 3;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 20; // 0x14
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8
        };
        constexpr static const char field_types[] = "nif";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   3
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "SoundEmitterPillPoints.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct LiquidTypeMeta : public DBMeta<LiquidTypeMeta> {
        constexpr LiquidTypeMeta() { }

        constexpr static const std::uint32_t field_count = 19;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 180; // 0xB4
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24,  28,  32,  36,
            40,  44,  48,  52,  56,  60,  84,  92, 164
        };
        constexpr static const char field_types[] = "nsiiiiffffifiiisifi";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
            1,   1,   1,   1,   1,   6,   2,  18,   4
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "LiquidType.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct LiquidObjectMeta : public DBMeta<LiquidObjectMeta> {
        constexpr LiquidObjectMeta() { }

        constexpr static const std::uint32_t field_count = 6;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 24; // 0x18
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20
        };
        constexpr static const char field_types[] = "nffiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "LiquidObject.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct LiquidMaterialMeta : public DBMeta<LiquidMaterialMeta> {
        constexpr LiquidMaterialMeta() { }

        constexpr static const std::uint32_t field_count = 3;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 12; // 0xC
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8
        };
        constexpr static const char field_types[] = "nii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "LiquidMaterial.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct LightSkyboxMeta : public DBMeta<LightSkyboxMeta> {
        constexpr LightSkyboxMeta() { }

        constexpr static const std::uint32_t field_count = 3;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 12; // 0xC
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8
        };
        constexpr static const char field_types[] = "nsi";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "LightSkybox.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct LightFloatBandMeta : public DBMeta<LightFloatBandMeta> {
        constexpr LightFloatBandMeta() { }

        constexpr static const std::uint32_t field_count = 4;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 136; // 0x88
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  72
        };
        constexpr static const char field_types[] = "niif";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,  16,  16
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "LightFloatBand.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct LightMeta : public DBMeta<LightMeta> {
        constexpr LightMeta() { }

        constexpr static const std::uint32_t field_count = 8;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 60; // 0x3C
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24,  28
        };
        constexpr static const char field_types[] = "nifffffi";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1,   8
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "Light.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct GroundEffectTextureMeta : public DBMeta<GroundEffectTextureMeta> {
        constexpr GroundEffectTextureMeta() { }

        constexpr static const std::uint32_t field_count = 5;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 44; // 0x2C
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,  20,  36,  40
        };
        constexpr static const char field_types[] = "niiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   4,   4,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "GroundEffectTexture.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct GroundEffectDoodadMeta : public DBMeta<GroundEffectDoodadMeta> {
        constexpr GroundEffectDoodadMeta() { }

        constexpr static const std::uint32_t field_count = 3;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 12; // 0xC
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8
        };
        constexpr static const char field_types[] = "nsi";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "GroundEffectDoodad.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct FootprintTexturesMeta : public DBMeta<FootprintTexturesMeta> {
        constexpr FootprintTexturesMeta() { }

        constexpr static const std::uint32_t field_count = 2;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 8; // 0x8
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4
        };
        constexpr static const char field_types[] = "ns";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "FootprintTextures.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct MapMeta : public DBMeta<MapMeta> {
        constexpr MapMeta() { }

        constexpr static const std::uint32_t field_count = 19;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 80; // 0x50
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24,  28,  32,  36,
            40,  44,  48,  52,  60,  64,  68,  72,  76
        };
        constexpr static const char field_types[] = "nsiiiisissififiiiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
            1,   1,   1,   2,   1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "Map.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct LightParamsMeta : public DBMeta<LightParamsMeta> {
        constexpr LightParamsMeta() { }

        constexpr static const std::uint32_t field_count = 10;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 40; // 0x28
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24,  28,  32,  36

        };
        constexpr static const char field_types[] = "niiifffffi";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1,   1,   1,   1

        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "LightParams.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct LightIntBandMeta : public DBMeta<LightIntBandMeta> {
        constexpr LightIntBandMeta() { }

        constexpr static const std::uint32_t field_count = 4;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 136; // 0x88
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  72
        };
        constexpr static const char field_types[] = "niii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,  16,  16
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "LightIntBand.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct AreaTableMeta : public DBMeta<AreaTableMeta> {
        constexpr AreaTableMeta() { }

        constexpr static const std::uint32_t field_count = 23;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 104; // 0x68
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24,  28,  32,  36,
            40,  44,  48,  52,  68,  72,  76,  80,  84,  88,
            92,  96, 100
        };
        constexpr static const char field_types[] = "niiiiiiiiiisiiffiiiiiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
            1,   1,   1,   4,   1,   1,   1,   1,   1,   1,
            1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "AreaTable.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct AnimationDataMeta : public DBMeta<AnimationDataMeta> {
        constexpr AnimationDataMeta() { }

        constexpr static const std::uint32_t field_count = 6;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 24; // 0x18
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20
        };
        constexpr static const char field_types[] = "nsiiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "AnimationData.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SoundEntriesMeta : public DBMeta<SoundEntriesMeta> {
        constexpr SoundEntriesMeta() { }

        constexpr static const std::uint32_t field_count = 17;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 140; // 0x8C
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  52,  92,  96, 100, 104, 108,
            112, 116, 120, 124, 128, 132, 136
        };
        constexpr static const char field_types[] = "nissisfiffiiffffi";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,  10,  10,   1,   1,   1,   1,   1,
            1,   1,   1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "SoundEntries.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct SoundEntriesAdvancedMeta : public DBMeta<SoundEntriesAdvancedMeta> {
        constexpr SoundEntriesAdvancedMeta() { }

        constexpr static const std::uint32_t field_count = 26;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 104; // 0x68
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24,  28,  32,  36,
            40,  44,  48,  52,  56,  60,  64,  68,  72,  76,
            80,  84,  88,  92,  96, 100
        };
        constexpr static const char field_types[] = "nifiiiiiiiiifffffiiffffiif";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
            1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
            1,   1,   1,   1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = false;

        static const char* name() { return "SoundEntriesAdvanced.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

    struct VideoHardwareMeta : public DBMeta<VideoHardwareMeta> {
        constexpr VideoHardwareMeta() { }

        constexpr static const std::uint32_t field_count = 23;
        constexpr static const std::uint32_t index_column = 0;
        constexpr static const std::uint32_t record_size = 92; // 0x5C
        constexpr static const std::uint32_t field_offsets[] = {
            0,   4,   8,  12,  16,  20,  24,  28,  32,  36,
            40,  44,  48,  52,  56,  60,  64,  68,  72,  76,
            80,  84,  88
        };
        constexpr static const char field_types[] = "niiiiiiiiiiiiiiiiissiii";
        constexpr static const std::uint32_t array_sizes[] = {
            1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
            1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
            1,   1,   1
        };
        constexpr static const bool sparse_storage = false;
        constexpr static const bool has_string = true;

        static const char* name() { return "VideoHardware.dbc"; }

        static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, "");
        static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, "");
        static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, "");
    };

}

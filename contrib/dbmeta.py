from idautils import *
from idaapi import *
from os.path import *
from idc import *

indent_level = 0

def writeln(i = 0, l = ""):
  global f
  global indent_level
  
  indent_level = indent_level + i

  if indent_level > 0 and l != "":
    for k in range(indent_level):
      f.write("    ")
  f.write("%s\n" % l)

def append(l = ""):
  global f
  f.write(l)

def insert_indent():
  global f
  global indent_level
  for k in range(indent_level):
    f.write("    ")

# Do not use default set up, we'll call setup().
s = Strings()

field_type_map = {
  0: "i",
  1: "l",
  2: "s",
  3: "f",
}

field_size_map = {
  0: 4,
  1: 8,
  2: 4,
  3: 4
}

f = open("DBStorage.hpp", "w+")
writeln( 0, "#pragma once")
writeln()
writeln( 0, "#include <type_traits>")
writeln( 0, "#include <cstdint>")
writeln( 0, "#include <vector>")
writeln()
writeln( 0, "// AUTOGENERATED FILE - DO NOT EDIT")
writeln( 0, "// See contrib/dbmeta.py")
writeln( 0, "namespace wowgm::game::datastores")
writeln( 0, "{")
writeln( 1, "template <typename T, typename Meta>")
writeln( 0, "struct DBCStorage")
writeln( 0, "{")
writeln( 1, "static_assert(!Meta::sparse_storage);")
writeln()
writeln( 0, "DBCStorage() { }")
writeln()
writeln( 0, "void LoadRecords(std::uint32_t recordCount, std::uint8_t* data, std::uint32_t stringPool);")
writeln()
writeln(-1, "private:")
writeln( 1, "std::vector<T> _storage;")
writeln(-1, "};")
writeln(-1, "}")
writeln()
f.close()

f = open("DBCMeta.hpp", "w+")
writeln( 0, "#pragma once")
writeln()
writeln( 0, "#include <type_traits>")
writeln( 0, "#include <cstdint>")
writeln( 0, "#include <vector>")
writeln()
writeln( 0, "// AUTOGENERATED FILE - DO NOT EDIT")
writeln( 0, "// See contrib/dbmeta.py")
writeln( 0, "namespace wowgm::game::datastores")
writeln( 0, "{")

writeln( 1, "template <typename T>")
writeln( 0, "struct DBMeta {")
writeln( 1, "static void AdjustStringOffsets(std::uint8_t* record, std::uint32_t stringTableOffset) {")
writeln( 1, "if (!T::has_string)")
writeln( 1, "return;")
writeln()
writeln(-1, "for (std::uint32_t i = 0; i < T::field_count; ++i) {")
writeln( 1, "if (T::field_types[i] != 's')")
writeln( 1, "continue;");
writeln()
writeln( -1, "*reinterpret_cast<std::uintptr_t*>(record + T::field_offsets[i]) += stringTableOffset;")
writeln( -1, "}")
writeln( -1, "}")
writeln( -1, "};")
writeln(-1)

for i, v in enumerate(s):
  sv = str(v)
  fnf = sv.rpartition('\\')[2]
  fn = fnf.rpartition('.')[0]
  if fn == "Item-sparse":
    fn = "ItemSparse"
  xpc2 = sv.endswith("2")
  if sv.startswith("DBFilesClient"):
    vx = XrefsTo(v.ea, 0)
    delta = 0x00 if not xpc2 else 0x04
    for vxx in vx:
      writeln( 1, "struct %sMeta : public DBMeta<%sMeta> {" % (fn, fn))
      writeln( 1, "constexpr %sMeta() { }" % fn)
      writeln()
      
      field_count = idc.Dword(vxx.frm + 0x04 + delta)
      record_size = idc.Dword(vxx.frm + 0x08 + delta)
      index_column = idc.Dword(vxx.frm + 0x10 + delta)
      field_offsets_ptr = idc.Dword(vxx.frm + 0x14 + delta * 2)
      field_sizes_ptr = idc.Dword(vxx.frm + 0x18 + delta * 2)
      field_types_ptr = idc.Dword(vxx.frm + 0x1C + delta * 2)
      streamed_str = idc.Dword(vxx.frm + 0x0C + delta * 2) == 0
      
      writeln( 0, "constexpr static const std::uint32_t field_count = %d;" % field_count);
      writeln( 0, "constexpr static const std::uint32_t index_column = %d;" % index_column)
      writeln( 0, "constexpr static const std::uint32_t record_size = %d; // 0x%X" % (record_size, record_size));
      writeln( 0, "constexpr static const std::uint32_t field_offsets[] = {");
      insert_indent()
      for i in range(field_count):
        fmt_str = "%4d" if i + 1 == field_count else "%4d,"
        append(fmt_str % idc.Dword(field_offsets_ptr + i * 4))
        
        if ((i + 1) % 10) == 0:
          writeln()
          insert_indent()

      writeln()
      writeln( 0, "};")
      
      any_str = False
      insert_indent()
      append("constexpr static const char field_types[] = \"")
      for i in range(field_count):
        f_type = idc.Dword(field_types_ptr + i * 4)
        f_type_str = field_type_map.get(f_type, "{}".format(f_type))
        if i == index_column:
          f_type_str = "n"

        if f_type_str == "s":
          any_str = True

        append("%s" % f_type_str)
      append("\";")
      writeln()
      
      writeln( 0, "constexpr static const std::uint32_t array_sizes[] = {")
      insert_indent()
      for i in range(field_count):
        fmt_str = "%4d" if i + 1 == field_count else "%4d,"
        i_type = idc.Dword(field_types_ptr + i * 4)
        append(fmt_str % (idc.Dword(field_sizes_ptr + i * 4) / int(field_size_map.get(i_type, 4))))
        
        if ((i + 1) % 10) == 0:
          writeln()
          insert_indent()
        
      writeln()
      writeln( 0, "};")

      writeln( 0, "constexpr static const bool sparse_storage = %s;" % ("true" if streamed_str else "false"))
      writeln( 0, "constexpr static const bool has_string = %s;" % ("true" if any_str else "false"))
      writeln()
      writeln( 0, "static const char* name() { return \"%s\"; }" % fnf)

      writeln();
      
      writeln( 0, "static_assert(sizeof(field_offsets) / sizeof(std::uint32_t) == field_count, \"\");")
      writeln( 0, "static_assert(sizeof(field_types) / sizeof(char) == field_count + 1, \"\");")
      writeln( 0, "static_assert(sizeof(array_sizes) / sizeof(std::uint32_t) == field_count, \"\");")
      
      writeln(-1, "};")
      writeln(-1)
      break

    print "Dumped %s" % str(v)

print "Saved to %s" % os.path.realpath(f.name)
writeln(-1, "}");
f.close()